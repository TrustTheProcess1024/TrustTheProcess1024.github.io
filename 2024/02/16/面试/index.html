<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="点开查看全文">
<meta property="og:type" content="article">
<meta property="og:title" content="面试">
<meta property="og:url" content="http://example.com/2024/02/16/%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="点开查看全文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8a0c1c8b2f274d7d998d62f86e6d61e1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/07a5bac4ce1743bcb6f856c903eb20b4.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/12395513/1645626833433-d4524497-96c4-4c5f-bf92-fdd93e433d2b.png?x-oss-process=image%2Fresize%2Cw_916%2Climit_0">
<meta property="og:image" content="https://img2022.cnblogs.com/blog/658190/202209/658190-20220924173343993-2057715647.png">
<meta property="og:image" content="https://oss.javaguide.cn/p3-juejin/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.png">
<meta property="og:image" content="https://oss.javaguide.cn/p3-juejin/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-c5d49f309b370b3b3029edea96c9f313_720w.webp">
<meta property="og:image" content="http://example.com/2024/02/16/%E9%9D%A2%E8%AF%95/image-20240324110154446.png">
<meta property="og:image" content="http://example.com/image-20240324110132369.png">
<meta property="og:image" content="http://example.com/image-20240305133028540.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png">
<meta property="og:image" content="http://example.com/image-20240219000021096.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/184e6328ba81b66728f8947bd61cf53d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ea56af9d9cc78fd226e66d2b11d59ab5.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/12395513/1648974998712-59df3d37-7aa8-4bea-a31a-4ae3777b0438.png?x-oss-process=image%2Fresize%2Cw_641%2Climit_0">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png">
<meta property="og:image" content="http://example.com/image-20240304151906028.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/threadlocal-data-structure.png">
<meta property="og:image" content="https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-UftlG_nP.png">
<meta property="og:image" content="http://example.com/2024/02/16/%E9%9D%A2%E8%AF%95/image-20240220152016280.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png">
<meta property="og:image" content="http://example.com/image-20240221001543512.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-implementation.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-sweep-garbage-collection-algorithm.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/copying-garbage-collection-algorithm.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-compact-garbage-collection-algorithm.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/12395513/1657072425889-6c1e10c2-838e-41f5-afaf-f1afc15427e2.png?x-oss-process=image%2Fresize%2Cw_721%2Climit_0">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/12395513/1661341347229-a5749e8e-c5f3-483c-a3d3-8444216b998d.png?x-oss-process=image/resize,w_730,limit_0">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2166218/gtgb7de111.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/12395513/1655430610802-ca0af4b8-a48d-4d36-8737-597136e08f11.png">
<meta property="og:image" content="http://example.com/image-20240305231505465.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/12395513/1657679756128-8d71285a-5e1d-4d8f-9a2d-ac25d9ed88fa.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E7%89%88%E6%9C%AC%E9%93%BE.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0">
<meta property="og:image" content="https://img-blog.csdnimg.cn/cc1118ba231242428b11d75ee50ce38f.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201204140551526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FzYWFzYTE=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/string.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/list.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/hash.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/set.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/zset.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/28afd536c57a46447ddab0a2062abe84.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/5a1f2a90b5f3821c19bea3b7a5f27fa1.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/d4cfac545377b54dd035c775603b4936.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309231944807.png">
<meta property="og:image" content="http://example.com/2024/02/16/%E9%9D%A2%E8%AF%95/image-20240225144453646.png">
<meta property="og:image" content="http://example.com/2024/02/16/%E9%9D%A2%E8%AF%95/image-20240225151655223.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-545476a6f045750c2a0452c290cb2397_720w.webp">
<meta property="og:image" content="https://pics1.baidu.com/feed/2e2eb9389b504fc231c6e024ac4e141a91ef6d91.jpeg@f_auto?token=f6189f00209eddf647fc3570ef15def2">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/application-layer-protocol.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/12395513/1647849158167-ea140a92-e16e-49f6-ae6b-5cb7a21165d9.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/12395513/1657955609001-38ed499f-14f0-4c3c-ae11-5f5aa529c75a.png?x-oss-process=image%2Fresize%2Cw_732%2Climit_0">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/12395513/1649213788873-bc420706-7ab0-440b-a723-a2f24d2bdd89.png?x-oss-process=image/resize,w_673,limit_0">
<meta property="og:image" content="http://example.com/image-20240319222922475.png">
<meta property="og:image" content="http://example.com/2024/02/16/%E9%9D%A2%E8%AF%95/image-20240319232345459.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png">
<meta property="og:image" content="http://example.com/image-20240315121258406.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/12395513/1658584505300-82768973-9c2c-4943-b791-6df5a128d907.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/page-table.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/paging-virtual-address-composition.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E9%93%BE%E6%8E%A5-2.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E9%93%BE%E6%8E%A5.png">
<meta property="og:image" content="https://oss.javaguide.cn/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/1704860a4de235aa~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/TLH3CicPVibrc82aq55YicGXslH31WPb6PaUmHKnOawJ3fPcP4jeylwbtlpRGAVeU4H0ug359LAAbzADbz6HMIAfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201207001947787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/de6d2b213f112297298f3e223bf08f28.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e2dbe61112c34462afd48f75911c057c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/dd0361f8f3934de3a43c62a0d1c46904.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0e88e51f95d045f5875badbc2c91dd36.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4f4e8e4591874d36bda9e2567f04fdca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5om25oiR6LW35p2l77yB5oiR6L-Y6IO956CB77yB,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/Asynchronous-message-queue.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/%E5%89%8A%E5%B3%B0-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png">
<meta property="og:image" content="https://developer.qcloudimg.com/http-save/yehe-2596032/c0761a21e3aad1659bc4cb8489263518.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/direct/07357cf763054314af4629d202209fcf.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/direct/cfa72f38430641bea46719e89e1c327e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/db03a51ee7cd44c3bcb3e35b47e78b20.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwMTgzOQ==,size_16,color_FFFFFF,t_60">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/5f64aaed183d54d9b9885c891674840f.png">
<meta property="og:image" content="http://example.com/2024/02/16/%E9%9D%A2%E8%AF%95/image-20240316205936166.png">
<meta property="article:published_time" content="2024-02-16T06:31:27.000Z">
<meta property="article:modified_time" content="2024-04-01T01:42:04.108Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="常见面试问题及答案">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/8a0c1c8b2f274d7d998d62f86e6d61e1.png">

<link rel="canonical" href="http://example.com/2024/02/16/%E9%9D%A2%E8%AF%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/16/%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-16 14:31:27" itemprop="dateCreated datePublished" datetime="2024-02-16T14:31:27+08:00">2024-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-01 09:42:04" itemprop="dateModified" datetime="2024-04-01T09:42:04+08:00">2024-04-01</time>
              </span>

          
            <div class="post-description">点开查看全文</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="聊聊面向对象的三大特性"><a href="#聊聊面向对象的三大特性" class="headerlink" title="聊聊面向对象的三大特性"></a>聊聊面向对象的三大特性</h4><p>封装：将一个对象的状态和行为包装在一起，形成一个独立的单元，并对外界隐藏其内部实现的细节。</p>
<p>继承：在已有类的基础上定义新的类，新类可以继承原有类的属性和方法。继承的主要作用是实现代码的重用和扩展。</p>
<p>多态：同一操作作用于不同的对象，可以产生不同的结果。</p>
<p>多态分为编译时多态和运行时多态，重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法。我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。</p>
<p>Java实现多态有 3 个必要条件：<strong>继承</strong>、<strong>重写</strong>和<strong>向上转型</strong>。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。</p>
<p>继承：在多态中必须存在有继承关系的子类和父类。</p>
<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。</p>
<p><strong>引申：</strong>构造器是否可以被重写？</p>
<p>答：构造器不能被继承，因此不能被重写，但可以被重载。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须一开始调用父类的构造函数。</p>
<h4 id="抽象类和接口的区别？"><a href="#抽象类和接口的区别？" class="headerlink" title="抽象类和接口的区别？"></a>抽象类和接口的区别？</h4><ol>
<li>Java中继承是单继承，但是可以实现多个接口</li>
<li>抽象类是对事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类体现了模板式设计，而接口是一种行为规范。</li>
</ol>
<h4 id="Java-中的⼏种基本数据类型是什么？对应的包装类型是什么？各⾃占⽤多少字节呢？"><a href="#Java-中的⼏种基本数据类型是什么？对应的包装类型是什么？各⾃占⽤多少字节呢？" class="headerlink" title="Java 中的⼏种基本数据类型是什么？对应的包装类型是什么？各⾃占⽤多少字节呢？"></a>Java 中的⼏种基本数据类型是什么？对应的包装类型是什么？各⾃占⽤多少字节呢？</h4><p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li>6 种数字类型： <ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ul>
<p>这八种基本类型对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code>。</p>
<p>8种基本数据类型的默认值及所占空间大小如下所示：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128~127</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-32768（-2^15） ~ 32767（2^15 - 1）</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>8</td>
<td>0L</td>
<td>-9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1）</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
<td>0 ~ 65535（2^16 - 1）</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td>1.4E-45 ~ 3.4028235E38</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td></td>
<td>false</td>
<td>true、false</td>
</tr>
</tbody></table>
<h4 id="String-、-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#String-、-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h4><p><strong>三者的区别：</strong></p>
<ol>
<li><p>可变性</p>
<p>String不可变</p>
<p>StringBuffer和StringBuilder可变</p>
</li>
<li><p>线程安全</p>
</li>
</ol>
<p>​		String不可变，因此线程安全</p>
<p>​		StringBuilder线程不安全（效率更高 适用于可变  且只需单线程访问的情况）</p>
<p>​		StringBuffer是线程安全的，内部使用 synchronized 进行同步（适用于可变 多线程访问的情况）</p>
<p><strong>String为什么不可变：</strong></p>
<p>String类中使用<code>final</code>关键字修饰字符数组来保存字符串，同时没有提供&#x2F;暴露修改这个字符数组的方法。</p>
<h4 id="String-s1-new-String-“abc”-这段代码创建了⼏个字符串对象？"><a href="#String-s1-new-String-“abc”-这段代码创建了⼏个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”); 这段代码创建了⼏个字符串对象？"></a>String s1 &#x3D; new String(“abc”); 这段代码创建了⼏个字符串对象？</h4><p><strong>会创建 1 或 2 个字符串对象。</strong></p>
<p>这里需要知道字符串常量池这个概念，<strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<p><img src="https://img-blog.csdnimg.cn/8a0c1c8b2f274d7d998d62f86e6d61e1.png" alt="img"></p>
<img src="https://img-blog.csdnimg.cn/07a5bac4ce1743bcb6f856c903eb20b4.png" alt="img" style="zoom: 67%;" />

<p>字符串常量池中存储了字符串常量对象及其引用。</p>
<p>回到问题，当字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p>
<p>当字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<h4 id="与equals？hashCode与equals？"><a href="#与equals？hashCode与equals？" class="headerlink" title="&#x3D;&#x3D;与equals？hashCode与equals？"></a>&#x3D;&#x3D;与equals？hashCode与equals？</h4><p><strong>&#x3D;&#x3D;与equals的区别：</strong></p>
<p>对于基本数据类型，&#x3D;&#x3D;比较的是值；equals是Object中的方法，不能用于基本数据类型</p>
<p>对于引用数据类型，&#x3D;&#x3D;比较的是对象的内存地址；而equals方法如果没有重写的话也是比较的对象的内存地址，一般都需要重写来比较对象中的属性是否相等。</p>
<p><strong>hashCode与equals：</strong></p>
<p>hashCode()方法用于获取对象的哈希码，从而确定该对象在哈希表中的索引位置。</p>
<p>hashCode与equals其实都是为了比较两个对象是否相等：</p>
<ul>
<li><p>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</p>
</li>
<li><p>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p>
</li>
<li><p>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</p>
</li>
</ul>
<p>一般来说，重写equals方法也必须重写hashCode方法，如果不重写的话将对象放入HashSet、HashMap这些容器就会存在问题。</p>
<h4 id="包装类型的缓存机制了解吗"><a href="#包装类型的缓存机制了解吗" class="headerlink" title="包装类型的缓存机制了解吗"></a>包装类型的缓存机制了解吗</h4><p>缓存机制指如果包装类的值在一定范围内，创建包装类对象时会直接返回缓存中的对象，否则需要创建新对象。</p>
<p>Java 包装类缓存机制是通过静态成员变量来实现的。在 Integer、Long、Short、Byte、Character 这五个包装类中，定义了一个静态数组 cache[]，用于缓存常用的数值。</p>
<p>Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False</p>
<p>两种浮点数类型的包装类 Float,Double 并没有缓存机制。</p>
<h4 id="深拷贝和浅拷贝了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝了解吗？什么是引用拷贝？</h4><img src="https://cdn.nlark.com/yuque/0/2022/png/12395513/1645626833433-d4524497-96c4-4c5f-bf92-fdd93e433d2b.png?x-oss-process=image%2Fresize%2Cw_916%2Climit_0" alt="image.png" style="zoom:67%;" />

<p>拷贝一般分为二大类 <strong>引用拷贝</strong> 和 <strong>对象拷贝</strong>，我们通常讲的<code>深拷贝</code>和<code>浅拷贝</code>都属于<strong>对象拷贝</strong>，其区别在于：</p>
<ul>
<li>浅拷贝： 对基本数据类型进行值传递； 对引用类型，复制了一份引用类型的变量  里面存储的内存地址一样  指向的对象也一样</li>
<li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ul>
<h4 id="Exception和Err有什么区别"><a href="#Exception和Err有什么区别" class="headerlink" title="Exception和Err有什么区别"></a>Exception和Err有什么区别</h4><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><code>Exception</code>：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><code>Error</code>：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<p><strong>引申问题：JVM是如何处理异常的？</strong></p>
<p>答：在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p>
<h4 id="Java的序列化和反序列化是什么？序列化的时候serialVersionUID有什么用？"><a href="#Java的序列化和反序列化是什么？序列化的时候serialVersionUID有什么用？" class="headerlink" title="Java的序列化和反序列化是什么？序列化的时候serialVersionUID有什么用？"></a>Java的序列化和反序列化是什么？序列化的时候serialVersionUID有什么用？</h4><p>序列化：序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。</p>
<p>反序列化：客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
<p>serialVersionUID 用来表明类的不同版本间的兼容性，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。如果显示不指定serialVersionUID，JVM会默认生成一个，那么如果类进行修改了之后可能引起反序列化失败。</p>
<h4 id="Java-反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？"><a href="#Java-反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？" class="headerlink" title="Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？"></a>Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</h4><p><strong>什么是反射：</strong>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取类信息以及动态调用对象的方法的功能称为java的反射机制。</p>
<p><strong>反射的优缺点：</strong>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>
<p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点。</p>
<p><strong>为什么框架需要反射：</strong></p>
<ol>
<li>动态加载类：框架需要能够在运行时加载和使用未知的类，而不需要在编译时将这些类直接引入代码中。通过反射，框架可以根据配置文件或用户输入来动态加载所需的类，从而提供更大的灵活性和可扩展性。</li>
<li>运行时判断和操作类的成员：框架可能需要在运行时检查类的字段、方法、构造函数等成员，并根据需要对它们进行操作。反射提供了获取和修改类成员的能力，使得框架可以在运行时动态地执行这些操作。</li>
<li>实现通用代码：框架通常需要编写通用的、适用于各种类的代码，而不是针对特定类进行硬编码。通过反射，框架可以在不知道类具体信息的情况下，通过类的名称、方法签名等动态地调用相应的方法，实现通用的代码逻辑。</li>
<li>注解处理：反射可以用于处理注解（Annotations）。框架可以使用反射来扫描类、方法或字段上的注解，并根据注解的信息来执行相应的逻辑。这种机制在许多框架中被广泛使用，例如依赖注入框架（如Spring）和对象关系映射框架（如Hibernate）。</li>
</ol>
<p><img src="https://img2022.cnblogs.com/blog/658190/202209/658190-20220924173343993-2057715647.png" alt="image"></p>
<p><strong>反射的原理：</strong>获取一个类的Class对象，Class对象会有指向方法区中instanceKlass，以此来获取类的信息。</p>
<h4 id="Java-泛型了解么？什么是类型擦除？"><a href="#Java-泛型了解么？什么是类型擦除？" class="headerlink" title="Java 泛型了解么？什么是类型擦除？"></a>Java 泛型了解么？什么是类型擦除？</h4><p>泛型是 JDK1.5 的一个新特性，泛型就是将类型参数化，其在编译时才确定具体的参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。泛型的主要目标是提高 Java 程序的类型安全，编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常。</p>
<p>通配符是泛型的一种使用方式，表示参数的类型不确定，可以接收任意类型参数。</p>
<p><strong>类型擦除：</strong>泛型是一种语法糖，泛型这种语法糖的基本原理是类型擦除。Java中的泛型基本上都是在编译器这个层次来实现的，也就是说：泛型只存在于编译阶段，而不存在于运行阶段。在编译后的 class 文件中，是没有泛型这个概念的。在编译后，泛型类型参数会被擦除为其上界或Object类型。</p>
<h4 id="BIO，NIO，AIO有什么区别？"><a href="#BIO，NIO，AIO有什么区别？" class="headerlink" title="BIO，NIO，AIO有什么区别？"></a>BIO，NIO，AIO有什么区别？</h4><p>**BIO:**同步阻塞IO模型</p>
<p>在应用程序发起read调用后，会一直阻塞，直到内核把数据拷贝到用户空间</p>
<img src="https://oss.javaguide.cn/p3-juejin/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.png" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom:67%;" />

<p><strong>NIO：</strong>同步非阻塞模型</p>
<img src="https://oss.javaguide.cn/p3-juejin/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.png" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom:67%;" />

<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>然而这种IO模型也存在一定的问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<p>IO多路复用模型在一定程度上解决了这个问题：</p>
<p>IO多路复用是指用单线程去监听多个IO通道的就绪状态，从而降低资源开销，并且能够在某个IO通道有事件发生时得到通知，避免同步非阻塞IO中轮询等待的问题。Linux下实现I&#x2F;O多路复用的系统调用主要有select、poll和epoll。</p>
<p><img src="https://pic4.zhimg.com/80/v2-c5d49f309b370b3b3029edea96c9f313_720w.webp" alt="img"></p>
<p><strong>select&#x2F;poll：</strong></p>
<p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</p>
<p>但是 poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p>
<p><strong>epoll：</strong></p>
<p>1.epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述符</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，减少了内核和用户空间大量的数据拷贝和内存分配。</p>
<p>2.epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件链表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p>
<img src="image-20240324110154446.png" alt="image-20240324110154446" style="zoom: 80%;" />

<p><img src="/image-20240324110132369.png" alt="image-20240324110132369"></p>
<p>总结：</p>
<p><img src="/image-20240305133028540.png" alt="image-20240305133028540"></p>
<p>Java中的NIO可以实现IO多路复用模型，通过Selector和Channel来实现。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png" alt="Buffer、Channel和Selector三者之间的关系"></p>
<p>首先需要创建一个Selector对象，然后将Channel注册到Selector上，并指定您关注的事件类型。接下来，使用Selector的select()方法等待就绪的事件。一旦事件就绪，您可以从Selector中获取已就绪的SelectionKey，然后处理相应的IO操作。</p>
<h4 id="JDK8中的新特性"><a href="#JDK8中的新特性" class="headerlink" title="JDK8中的新特性"></a>JDK8中的新特性</h4><p>lambda表达式</p>
<p>stream流</p>
<h3 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h3><h4 id="说说-List-Set-Map-三者的区别？三者底层的数据结构？"><a href="#说说-List-Set-Map-三者的区别？三者底层的数据结构？" class="headerlink" title="说说 List,Set,Map 三者的区别？三者底层的数据结构？"></a>说说 List,Set,Map 三者的区别？三者底层的数据结构？</h4><p><code>List</code>存储的元素有序，可以重复；<code>set</code>存储的元素不可重复；Map存储的是K-V键值对，其中key不可重复，value可以重复。</p>
<p><code>List</code>的底层数据结构有：</p>
<ul>
<li><code>ArrayList</code>：<code>Object[]</code> 数组。</li>
<li><code>Vector</code>：<code>Object[]</code> 数组。</li>
<li><code>LinkedList</code>：双向链表</li>
</ul>
<p><code>Set</code>的底层数据结构有：</p>
<ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素。</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)。</li>
</ul>
<p><code>Map</code>的底层数据结构有：</p>
<ul>
<li><code>HashMap</code>：重要集合，后面具体分析</li>
<li><code>LinkedHashMap</code>：在HashMap的基础上增加了一条双向链表，保持键值对的插入顺序。</li>
<li><code>HashTable</code>：Map的早期实现，线程安全，性能不高</li>
<li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li>
</ul>
<h4 id="LinkedList和ArrayList的区别？"><a href="#LinkedList和ArrayList的区别？" class="headerlink" title="LinkedList和ArrayList的区别？"></a>LinkedList和ArrayList的区别？</h4><ul>
<li>LinkedList底层实现采用链表，ArrayList底层实现采用数组</li>
<li>LinkedList插入和删除的效率比ArrayList高</li>
<li>ArrayList随机访问的效率比LinkedList高</li>
</ul>
<h4 id="集合的线程安全问题？"><a href="#集合的线程安全问题？" class="headerlink" title="集合的线程安全问题？"></a>集合的线程安全问题？</h4><p>线程不安全的集合包括：HashMap、ArrayList、LinkedList、HashSet、TreeSet、TreeMap</p>
<p>线程安全的集合包括三类：</p>
<p><img src="/image-20240219000021096.png" alt="image-20240219000021096"></p>
<p>使用的较多的JUC包下面的线程安全集合类，包含三个关键词：Blocking、CopyOnWrite、Concurrent：</p>
<ul>
<li>Blocking大部分基于锁实现，并提供用来阻塞的方法</li>
<li>CopyOnWrite 之类容器的意思是写时复制，底层实现采用了 写入时拷贝 的思想，增删改操作会将容器底层存储结构拷贝一份，更改操作在新容器上执行，这时不影响其它线程的<strong>并发读</strong>，<strong>读写分离</strong>。 </li>
<li>Concurrent类容器一般在内部采用CAS优化，可以提供较高的吞吐量</li>
</ul>
<h4 id="Fail-fast和fail-safe？"><a href="#Fail-fast和fail-safe？" class="headerlink" title="Fail-fast和fail-safe？"></a>Fail-fast和fail-safe？</h4><h5 id="Fail-fast：快速失败"><a href="#Fail-fast：快速失败" class="headerlink" title="Fail-fast：快速失败"></a>Fail-fast：快速失败</h5><p>是Java集合中一种错误检测机制，当遍历集合的同时修改集合或者多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制，抛出ConcurrentModificationException 异常。</p>
<h5 id="fail-safe：安全失败"><a href="#fail-safe：安全失败" class="headerlink" title="fail-safe：安全失败"></a>fail-safe：安全失败</h5><p>采用fail-safe机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制集合内容，在拷贝的集合上进行遍历。</p>
<h4 id="HashMap解析"><a href="#HashMap解析" class="headerlink" title="HashMap解析"></a>HashMap解析</h4><h5 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h5><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p>JDK1.8前：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/184e6328ba81b66728f8947bd61cf53d.png" alt="184e6328ba81b66728f8947bd61cf53d.png" style="zoom: 80%;" />

<p>JDK1.8后：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ea56af9d9cc78fd226e66d2b11d59ab5.png" alt="ea56af9d9cc78fd226e66d2b11d59ab5.png"></p>
<p><strong>引申问题：为什么要用红黑树？</strong></p>
<p>红黑树是一颗自平衡二叉树，主要是避免 hash 冲突导致链表的长度过长，这样 get 的时候时间复杂度严格来说就不是 O(1) 了，因为可能需要遍历链表来进行查找。</p>
<h5 id="HashMap容量大小"><a href="#HashMap容量大小" class="headerlink" title="HashMap容量大小"></a>HashMap容量大小</h5><p>HashMap 默认的初始化大小为16  之后每次扩充，容量变为原来的 2 倍  若给定了容量初始值 则会扩充为2的幂次方大小</p>
<p>哈希表的key-value键值对（Entry)     利用散列函数对key计算hash值  然后通过数组大小 n-1 &amp; hash 值之后  得到目标元素的存储位置（例如数组下标） 然后在该位置存储或者提取key-value</p>
<p><strong>引申问题：为什么HashMap的容量是2的幂次？</strong></p>
<p>因为数组下标的计算公式用的是 i &#x3D; (n - 1) &amp; hash，即位运算，一般我们能想到的是 %（取余）计算，但相比于位运算而言，效率比较低，所以用位运算。当n是2的幂次时，满足公式(n-1)&amp;hash&#x3D;hash%n，因此n是2的幂次。</p>
<p><strong>引申问题：什么时候需要扩容？</strong></p>
<p>扩容操作和这些变量有关：capacity容量，loadFactor负载因子，threshold阈值&#x3D;容量*负载因子，超过阈值便会出发扩容。扩容也不是简单的把数组扩大，而是新创建一个数组是原来的2倍，然后把原数组的所有Entry都重新Hash一遍放到新的数组</p>
<h5 id="HashMap的线程安全问题"><a href="#HashMap的线程安全问题" class="headerlink" title="HashMap的线程安全问题"></a>HashMap的线程安全问题</h5><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>
<p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p>
<h4 id="ConcurrentHashMap解析"><a href="#ConcurrentHashMap解析" class="headerlink" title="ConcurrentHashMap解析"></a>ConcurrentHashMap解析</h4><h5 id="ConcurrentHashMap底层实现方式"><a href="#ConcurrentHashMap底层实现方式" class="headerlink" title="ConcurrentHashMap底层实现方式"></a>ConcurrentHashMap底层实现方式</h5><p>JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
<h5 id="ConcurrentHashMap实现线程安全的方式"><a href="#ConcurrentHashMap实现线程安全的方式" class="headerlink" title="ConcurrentHashMap实现线程安全的方式"></a>ConcurrentHashMap实现线程安全的方式</h5><ul>
<li><strong>JDK1.7 分段锁</strong>  对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 这里的<code>Segment</code> 是继承自 <code>ReentrantLock</code>，叫分段锁。</li>
<li><strong>JDK1.8</strong> 已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 <strong>synchronized 和 CAS</strong> 来操作。整个看起来就像是优化过且线程安全的 HashMap，synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍，并发度更大</li>
</ul>
<img src="https://cdn.nlark.com/yuque/0/2022/png/12395513/1648974998712-59df3d37-7aa8-4bea-a31a-4ae3777b0438.png?x-oss-process=image%2Fresize%2Cw_641%2Climit_0" alt="image.png" style="zoom: 80%;" />

<h5 id="ConcurrenHashMap的get方法里面有做并发处理吗？"><a href="#ConcurrenHashMap的get方法里面有做并发处理吗？" class="headerlink" title="ConcurrenHashMap的get方法里面有做并发处理吗？"></a>ConcurrenHashMap的get方法里面有做并发处理吗？</h5><p>有的，只是不是用加锁的方式，因为get操作只是读取数据，并不修改内部的数据结构，但是它可能会与写操作并发，所以ConcurrentHashMap中的关键字段，如内部节点数组（Node&lt;K,V&gt;[] table），被声明为volatile。这意味着对这些字段的写入会立即对其他线程可见，从而确保了在并发环境下读取到的是最新的数据。</p>
<h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h3><h4 id="什么是线程和进程-线程与进程的关系-区别及优缺点？"><a href="#什么是线程和进程-线程与进程的关系-区别及优缺点？" class="headerlink" title="什么是线程和进程?线程与进程的关系,区别及优缺点？"></a>什么是线程和进程?线程与进程的关系,区别及优缺点？</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>进程与线程的关系：</strong></p>
<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）" style="zoom:80%;" />

<p>从JVM的角度来说，一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p>优缺点：</p>
<p>进程优点：地址空间独立，更加安全。缺点：上下文切换时开销大。</p>
<p>线程优点：切换和调度的成本远小于进程。缺点：共享资源容易引发并发安全问题。</p>
<h4 id="死锁产生的条件？如何预防和避免死锁？"><a href="#死锁产生的条件？如何预防和避免死锁？" class="headerlink" title="死锁产生的条件？如何预防和避免死锁？"></a>死锁产生的条件？如何预防和避免死锁？</h4><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p>
<p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p>
<p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</p>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<h4 id="乐观锁和悲观锁了解么？如何实现乐观锁？"><a href="#乐观锁和悲观锁了解么？如何实现乐观锁？" class="headerlink" title="乐观锁和悲观锁了解么？如何实现乐观锁？"></a>乐观锁和悲观锁了解么？如何实现乐观锁？</h4><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问就会出现问题，因此每次获取共享资源时都会上锁，只给一个线程使用，其他线程阻塞。</p>
<p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了。</p>
<p>如何实现乐观锁：</p>
<p>1.版本号</p>
<p>2.CAS：CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
<h4 id="CAS的实际应用：原子类"><a href="#CAS的实际应用：原子类" class="headerlink" title="CAS的实际应用：原子类"></a>CAS的实际应用：原子类</h4><p>Java中的原子类采用CAS的方式实现原子更新，如AtomicInteger类的incrementAndGet()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用compareAndSet方法来来进行原子更新操作，这个方法的语义是：</p>
<p><strong>先检查当前value是否等于current，如果相等，则意味着value没被其他线程修改过，更新并返回true。如果不相等，compareAndSet则会返回false，然后循环继续尝试更新。</strong></p>
<h4 id="说说-sleep-⽅法和-wait-⽅法区别和共同点"><a href="#说说-sleep-⽅法和-wait-⽅法区别和共同点" class="headerlink" title="说说 sleep() ⽅法和 wait() ⽅法区别和共同点?"></a>说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</h4><p>共同点：都可以暂停线程的执行</p>
<p>区别：</p>
<ul>
<li>sleep()操作不会释放锁，而wait()操作会释放锁</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li>sleep()是Thread类的静态本地方法，wait()是Object类的本地方法</li>
</ul>
<h4 id="讲⼀下-JMM-Java-内存模型-。-volatile-关键字解决了什么问题？说说-synchronized-关键字和-volatile-关键字的区别。"><a href="#讲⼀下-JMM-Java-内存模型-。-volatile-关键字解决了什么问题？说说-synchronized-关键字和-volatile-关键字的区别。" class="headerlink" title="讲⼀下 JMM(Java 内存模型)。 volatile 关键字解决了什么问题？说说 synchronized 关键字和 volatile 关键字的区别。"></a>讲⼀下 JMM(Java 内存模型)。 volatile 关键字解决了什么问题？说说 synchronized 关键字和 volatile 关键字的区别。</h4><p>JMM是Java编程语言用来定义多线程程序中内存访问行为的规范。它决定了在多线程环境下，一个线程如何通过主内存与其他线程进行通信以及如何访问共享数据。</p>
<p>volatile关键字可以保证变量的可见性和有序性。</p>
<p><strong>可见性：</strong>声明为volatile的变量在每次写入时会把该线程对应的本地内存中的共享变量刷新到主内存；在读取时会把线程对应的本地内存置为无效，从主内存中读取共享变量。</p>
<p><strong>有序性：</strong>在volatile变量的写入操作之前的指令不会被重新排序到写入操作之后，同样，在volatile变量的读取操作之后的指令不会被重新排序到读取操作之前。</p>
<p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
<li><code>synchronized</code>可能引起线程阻塞， <code>volatile</code>不会造成线程阻塞。</li>
</ul>
<h4 id="Java-内存区域和-JMM-有何区别？"><a href="#Java-内存区域和-JMM-有何区别？" class="headerlink" title="Java 内存区域和 JMM 有何区别？"></a>Java 内存区域和 JMM 有何区别？</h4><p>JMM是Java多线程编程中的规范，定义了多线程程序中的内存访问行为。而Java内存区域是Java虚拟机在运行时划分的不同内存区域，用于存储不同类型的数据。JMM关注的是多线程程序的内存模型，而Java内存区域关注的是Java虚拟机的内存结构和管理。</p>
<h4 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens before 原则"></a>happens before 原则</h4><p>happens before原则定义两个操作之间的内存可见性，如果A操作happens before B操作，则A操作的操作结果对于B操作是可见的。</p>
<h4 id="synchronized-关键字的作⽤"><a href="#synchronized-关键字的作⽤" class="headerlink" title="synchronized 关键字的作⽤"></a>synchronized 关键字的作⽤</h4><p>synchronized主要用于解决多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>synchronized保证<strong>原子性</strong>：synchronized保证语句块内操作是原子的</p>
<p>synchronized也可以保证<strong>可见性</strong>：</p>
<ol>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li>
<li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存<br>中重新读取最新的值。</li>
</ol>
<p>synchronized保证<strong>有序性</strong>：通过“一个变量在同一时刻只允许一条线程对其进行lock操作”</p>
<h4 id="synchronized和reentrantLock的区别"><a href="#synchronized和reentrantLock的区别" class="headerlink" title="synchronized和reentrantLock的区别"></a>synchronized和reentrantLock的区别</h4><ol>
<li>锁的实现：synchronized是JVM实现的，而ReentrantLock是JDK实现的</li>
<li>ReentrantLock可以被中断，持有锁的线程可以被打断。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。</li>
<li>ReentrantLock支持多个条件变量</li>
</ol>
<h4 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h4><p>synchronized基于对象监视器monitor来实现代码块同步，每个 Java 对象都可以关联一个 Monitor 对象，线程通过synchronized给对象上锁之后就会成为该对象关联的monitor的owner，此时有其他线程竞争锁的话就会进入该monitor的EntryList进行阻塞等待。同时moniter还有一个waitSet，持有锁的线程调用wait()方法之后便会进入waitSet，等待被notify唤醒，唤醒后需要重新进入EntrySet竞争锁。</p>
<p><img src="/image-20240304151906028.png" alt="image-20240304151906028"></p>
<h4 id="ThreadLocal-关键字的作⽤，内存泄露问题"><a href="#ThreadLocal-关键字的作⽤，内存泄露问题" class="headerlink" title="ThreadLocal 关键字的作⽤，内存泄露问题"></a>ThreadLocal 关键字的作⽤，内存泄露问题</h4><p>ThreadLocal变量是线程的本地变量，线程安全，一般会用它保存线程上下文信息。</p>
<p>Thread类中存在ThreadLocalMap变量，ThreadLocalMap存储存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/threadlocal-data-structure.png" alt="ThreadLocal 数据结构"></p>
<p>内存泄漏：对象已经没有被程序使用  但是因为还在被引用着 导致垃圾回收器没办法清除</p>
<p><strong>ThreadLocal解决内存泄漏：</strong></p>
<p>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>
<p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p>
<p>ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。</p>
<h4 id="线程池有什么⽤？为什么不推荐使⽤内置线程池？"><a href="#线程池有什么⽤？为什么不推荐使⽤内置线程池？" class="headerlink" title="线程池有什么⽤？为什么不推荐使⽤内置线程池？"></a>线程池有什么⽤？为什么不推荐使⽤内置线程池？</h4><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<p>线程池的作用：</p>
<ul>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ul>
<p>创建线程池一般有两种方法：</p>
<ol>
<li><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></li>
</ol>
<img src="https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-UftlG_nP.png" alt="通过构造方法实现" style="zoom:80%;" />

<p>   2.<strong>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p>
<p>​	Executors工具类提供了一些默认的线程池实现：</p>
<ul>
<li>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li>
<li>**<code>ScheduledThreadPool</code>**：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li>
</ul>
<p>为什么不推荐使用内置线程池：</p>
<p><code>Executors</code> 返回线程池对象存在一些弊端如下：</p>
<ul>
<li>**<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>**：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li>**<code>CachedThreadPool</code>**：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<h4 id="Java-线程池有哪些参数？阻塞队列有⼏种？拒绝策略有⼏种？"><a href="#Java-线程池有哪些参数？阻塞队列有⼏种？拒绝策略有⼏种？" class="headerlink" title="Java 线程池有哪些参数？阻塞队列有⼏种？拒绝策略有⼏种？"></a>Java 线程池有哪些参数？阻塞队列有⼏种？拒绝策略有⼏种？</h4><p><strong>线程池的参数：</strong></p>
<ol>
<li><code>corePoolSize(重要):</code>核心线程数，任务队列未达到队列容量时，最大可以同时运行的线程数量。核心线程执行常规任务</li>
<li><code>maximumPoolSize(重要):</code>最大线程数，任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。最大线程应对突发流量</li>
<li><code>workQueue(重要):</code>任务队列，新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 </li>
<li><code>keepAliveTime:</code>非核心线程空闲时长，线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li>
<li><code>unit:</code> <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :拒绝策略。当线程数达到最大线程数时就要执行饱和策略。</li>
</ol>
<h5 id="阻塞队列："><a href="#阻塞队列：" class="headerlink" title="阻塞队列："></a>阻塞队列：</h5><ol>
<li>同步队列，没有容量。</li>
<li>有界任务队列：ArrayBlockingQueue</li>
<li>无界任务队列：LinkedBlockingQueue</li>
<li>优先任务队列：PriorityBlockingQueue</li>
</ol>
<h5 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h5><p>1.AbortPolicy拒绝策略：新任务就会被拒绝，并且抛出RejectedExecutionException异常。该策略是线程池默认的拒绝策略。</p>
<p>2.DiscardPolicy抛弃策略：新的任务会被丢掉，并且不会有任何异常抛出</p>
<p>3.DiscardOldestPolicy抛弃最老任务策略：将最早进入队列的任务抛弃，从队列中腾出空间，再尝试加入队列</p>
<p>4.CallerRunsPolicy调用者执行策略：新任务被添加到线程池时，如果添加失败，那么提交任务的线程会自己去执行任务。</p>
<h4 id="线程池处理任务的流程了解吗？"><a href="#线程池处理任务的流程了解吗？" class="headerlink" title="线程池处理任务的流程了解吗？"></a>线程池处理任务的流程了解吗？</h4><img src="image-20240220152016280.png" alt="image-20240220152016280" style="zoom:80%;" />

<p>文字描述：</p>
<ol>
<li>向线程池提交任务时，如果线程池中的线程数小于核心线程数，则会创建一个新线程执行任务；</li>
<li>否则会判断任务队列是否已满，如果任务队列没满，则将任务放入任务队列中等待执行；</li>
<li>如果任务队列也已满，则会判断线程数是否达到最大线程数，如果没有则会创建一个新线程并执行任务；</li>
<li>否则的话则会通过拒绝策略来处理任务。</li>
<li>当线程执行完任务后，会再从任务队列中取任务执行，此时非核心线程会设置超时时间，如果空闲时间达到了超时时间则回收线程。</li>
</ol>
<h4 id="实现Runnable接口和Callable接口的区别"><a href="#实现Runnable接口和Callable接口的区别" class="headerlink" title="实现Runnable接口和Callable接口的区别"></a>实现Runnable接口和Callable接口的区别</h4><ol>
<li>实现Runnable接口需要重写Run()方法，该方法没有返回值；而实现Callable接口需要重写Call()方法，有返回值</li>
<li>run()方法不能抛出异常，需要在方法内部try,catch解决；Call()方法可以抛出异常。</li>
</ol>
<h4 id="Submit-和execute-方法有什么区别？"><a href="#Submit-和execute-方法有什么区别？" class="headerlink" title="Submit()和execute()方法有什么区别？"></a>Submit()和execute()方法有什么区别？</h4><ul>
<li>execute()方法只能接收Runnable类型的参数，而submit()方法可以接收Callable、Runnable两种类型的参数</li>
<li>submit()提交任务后会有返回值，而execute()没有</li>
<li>submit()可以抛出异常，execute不行</li>
</ul>
<h4 id="AQS是什么？AQS的三大组件？"><a href="#AQS是什么？AQS的三大组件？" class="headerlink" title="AQS是什么？AQS的三大组件？"></a>AQS是什么？AQS的三大组件？</h4><p>AQS抽象队列同步器，是用来构建锁或者其他同步组件的基础框架，AQS定义了一个线程排队获取共享资源的模型，其核心就是如果被请求的共享资源还有剩余，则将当前请求资源的线程置为有效工作线程，并将共享资源减少；如果不存在多的共享资源，则将线程阻塞并加入到同步队列的队尾进行等待。</p>
<p><strong>AQS节点怎么加入到线程排队队列：</strong>进入的线程的节点的pre指针指向tail，然后使用cas让对尾节点的next指针指向新添加节点，最后tail指向新增线程结点。   </p>
<p>使用了一个int类型的成员变量表示同步状态，通过内置的队列来完成资源获取线程的排队工作。</p>
<p>AQS使用CAS对同步状态变量进行原子操作来实现修改，并用volatile关键字保证其可见性。</p>
<p>AQS采用了模板方法设计模式，一些复杂的线程排队，阻塞&#x2F;唤醒等操作都由AQS实现好了，构建同步器只需要重写tryAcquire,tryRelease等方法。</p>
<p>AQS三个重要组件：</p>
<p>1.Semaphore</p>
<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>
<p>2.CountDownLatch</p>
<p>线程同步工具，允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p>
<p>3.CyclicBarrier</p>
<p>用来进行线程协作，等待线程满足某个计数。</p>
<p>构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。</p>
<h5 id="CountDownLatch和CyclicBarrier的区别"><a href="#CountDownLatch和CyclicBarrier的区别" class="headerlink" title="CountDownLatch和CyclicBarrier的区别"></a>CountDownLatch和CyclicBarrier的区别</h5><p>CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；</p>
<p>CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。</p>
<p><strong>CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</strong></p>
<p>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset()方法重置。</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="Java运行时数据区包含哪些？哪些线程共享哪些不共享？哪些区域可能出现OOM？哪些区域不会出现OOM？"><a href="#Java运行时数据区包含哪些？哪些线程共享哪些不共享？哪些区域可能出现OOM？哪些区域不会出现OOM？" class="headerlink" title="Java运行时数据区包含哪些？哪些线程共享哪些不共享？哪些区域可能出现OOM？哪些区域不会出现OOM？"></a>Java运行时数据区包含哪些？哪些线程共享哪些不共享？哪些区域可能出现OOM？哪些区域不会出现OOM？</h4><p>Java运行时数据区在JDK1.8前后有所不同：</p>
<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.7）" style="zoom:80%;" />

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom:80%;" />

<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存</li>
</ul>
<p>程序计数器是唯一一个不会出现OOM的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<p>下面对于Java运行时区域的一些概念进行总结：</p>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>Java堆是用来存储实例对象的，是垃圾回收的主要区域。</p>
<p>方法区的一些内容也是放在了堆中的：类的静态变量和字符串常量池。</p>
<p><img src="/image-20240221001543512.png" alt="image-20240221001543512"></p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
<p>JVM规定需要有方法区这样一个区域，具体如何实现则由虚拟机自己决定，方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p>
<p>为什么要用元空间替换永久代？</p>
<ol>
<li>永久代是在堆中的，受限于堆内存的限制，很难设置合理的大小。而元空间使用的是本地内存，仅受本机可用内存的限制，能加载的类就更多了。</li>
<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li>
</ol>
<h4 id="字符串常量池在什么位置（JDK1-7-之前在永久代，JDK1-7-在堆）？JDK-1-7-为什么要将字符串常量池移动到堆中？"><a href="#字符串常量池在什么位置（JDK1-7-之前在永久代，JDK1-7-在堆）？JDK-1-7-为什么要将字符串常量池移动到堆中？" class="headerlink" title="字符串常量池在什么位置（JDK1.7 之前在永久代，JDK1.7 在堆）？JDK 1.7 为什么要将字符串常量池移动到堆中？"></a>字符串常量池在什么位置（JDK1.7 之前在永久代，JDK1.7 在堆）？JDK 1.7 为什么要将字符串常量池移动到堆中？</h4><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<h4 id="堆空间的基本结构了解吗？什么情况下对象会进入老年代？"><a href="#堆空间的基本结构了解吗？什么情况下对象会进入老年代？" class="headerlink" title="堆空间的基本结构了解吗？什么情况下对象会进入老年代？"></a>堆空间的基本结构了解吗？什么情况下对象会进入老年代？</h4><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png" alt="堆内存结构"></p>
<p>堆空间的内存结构如上图所示，JDK1.8之前堆内存通常被划分为下面三部分：</p>
<ol>
<li>新生代内存，图中的Eden区，两个Survivor区S0和S1都属于新生代。</li>
<li>老年代内存。</li>
<li>永久代内存。</li>
</ol>
<p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong></p>
<p>对象进入老年代的情况：</p>
<ol>
<li>对象年龄到达阈值后进入老年代。</li>
<li>如果进行Minor GC时发现存活的对象在survivor区存不下，那么把存活的对象存入老年代。</li>
<li>大对象直接进入老年代。主要原因是新生代GC频繁，且经常采用复制算法，大对象复制起来开销太大。</li>
<li>动态年龄判断，Survivor区域里现在有一批对象，年龄1 + 年龄2 +…+年龄n 多个年龄对象总和超过了Survivor区域的50%，此时就会 把年龄n(含)以上 的对象都放入老年代。</li>
</ol>
<h4 id="直接内存有什么用？"><a href="#直接内存有什么用？" class="headerlink" title="直接内存有什么用？"></a>直接内存有什么用？</h4><p>直接内存是在Java堆外的、直接向系统申请的内存区间。直接内存常用于IO操作，直接内存能够被Java程序直接访问，操作系统也可以直接使用，在进行IO操作时就会少一次从系统缓冲区拷贝到用户缓冲区的过程。</p>
<h4 id="Java对象的创建过程⭐⭐"><a href="#Java对象的创建过程⭐⭐" class="headerlink" title="Java对象的创建过程⭐⭐"></a>Java对象的创建过程⭐⭐</h4><h5 id="Step1：类加载检查"><a href="#Step1：类加载检查" class="headerlink" title="Step1：类加载检查"></a>Step1：类加载检查</h5><p>首先要做的是检查这个类是否已经被加载、解析和初始化过，如果没有则应先执行相应的类加载过程。</p>
<h5 id="Step2：分配内存"><a href="#Step2：分配内存" class="headerlink" title="Step2：分配内存"></a>Step2：分配内存</h5><p>在经过类加载检查后，虚拟机将为新生对象分配内存。从堆中分配内存有“指针碰撞”和“空闲列表”两种方式，选择哪种方式由Java堆是否规整决定，而Java堆是否规整又与垃圾回收器是否带有整理功能决定。</p>
<p>内存分配的两种方式：</p>
<p>指针碰撞： </p>
<ul>
<li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
<p>空闲列表： </p>
<ul>
<li>适用场合：堆内存不规整的情况下。</li>
<li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
<h5 id="Step3：初始化零值"><a href="#Step3：初始化零值" class="headerlink" title="Step3：初始化零值"></a>Step3：初始化零值</h5><p>内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h5 id="Step4：设置对象头"><a href="#Step4：设置对象头" class="headerlink" title="Step4：设置对象头"></a>Step4：设置对象头</h5><p>初始化零值完成后，虚拟机会设置对象头，对象头中存放了类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>
<h5 id="Step5：执行init方法"><a href="#Step5：执行init方法" class="headerlink" title="Step5：执行init方法"></a>Step5：执行init方法</h5><p>在上面的工作完成后，一个新的对象已经产生了，这是应该执行对象的实例构造方法，去按照程序员的意愿初始化对象。</p>
<h4 id="谈谈你对-Minor-GC、还有-Full-GC-的理解。Minor-GC-与-Full-GC-分别在什么时候发⽣？-Minor-GC-会发⽣-stop-the-world-现象吗？"><a href="#谈谈你对-Minor-GC、还有-Full-GC-的理解。Minor-GC-与-Full-GC-分别在什么时候发⽣？-Minor-GC-会发⽣-stop-the-world-现象吗？" class="headerlink" title="谈谈你对 Minor GC、还有 Full GC 的理解。Minor GC 与 Full GC 分别在什么时候发⽣？ Minor GC 会发⽣ stop the world 现象吗？"></a>谈谈你对 Minor GC、还有 Full GC 的理解。Minor GC 与 Full GC 分别在什么时候发⽣？ Minor GC 会发⽣ stop the world 现象吗？</h4><p>Minor GC：回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行速度一般也会比较快</p>
<p>Full GC：回收新生代和老年代，老年代对象存活时间长，因此Full GC一般情况下应该很少执行，执行速度会慢很多</p>
<p>Minor GC的触发条件：</p>
<ul>
<li>当Eden区满了之后就会触发Minor GC</li>
</ul>
<p>Full GC的触发场景见下一问</p>
<p>Minor GC也会发生STW</p>
<h4 id="Full-GC的触发机制？"><a href="#Full-GC的触发机制？" class="headerlink" title="Full GC的触发机制？"></a><strong>Full GC的触发机制？</strong></h4><ol>
<li>调用System.gc方法，系统建议执行Full GC，但虚拟机不一定会执行</li>
<li>老年代空间不足</li>
<li>空间分配担保失败</li>
<li>JDK1.7及以前永久代空间不足</li>
</ol>
<h4 id="如何判断对象是否死亡（引⽤计数法和可达性分析算法两种⽅法）？"><a href="#如何判断对象是否死亡（引⽤计数法和可达性分析算法两种⽅法）？" class="headerlink" title="如何判断对象是否死亡（引⽤计数法和可达性分析算法两种⽅法）？"></a>如何判断对象是否死亡（引⽤计数法和可达性分析算法两种⽅法）？</h4><h5 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h5><p>原理：给每个对象分配一个计数器  当对象增加一个引用时计数器+1  减少一个引用时计数器-1 计数器为0的对象就是可以被回收的对象</p>
<p>缺点：对象出现<strong>循环引用</strong>的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。因为循环引用的存在，因此Java 虚拟机不使用引用计数算法。</p>
<h5 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h5><p>原理：以多个<strong>GC Roots</strong> 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>作为GC Roots 的对象包括：</p>
<ul>
<li>虚拟机栈中局部变量表引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>
<h4 id="四种引用类型知道吗？"><a href="#四种引用类型知道吗？" class="headerlink" title="四种引用类型知道吗？"></a>四种引用类型知道吗？</h4><ul>
<li>强引用：new的都是强引用 只要存活就不会被垃圾回收</li>
<li>软引用： JVM认为内存不足时会回收软引用指向的对象</li>
<li>弱引用：无论内存足不足 JVM都会回收弱引用指向的对象</li>
<li>虚引用：任何时候都可能被JVM回收</li>
</ul>
<h4 id="垃圾收集有哪些算法，各⾃的特点？"><a href="#垃圾收集有哪些算法，各⾃的特点？" class="headerlink" title="垃圾收集有哪些算法，各⾃的特点？"></a>垃圾收集有哪些算法，各⾃的特点？</h4><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li>
<li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li>
</ol>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-sweep-garbage-collection-algorithm.png" alt="标记-清除算法"></p>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/copying-garbage-collection-algorithm.png" alt="复制算法"></p>
<p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p>
<ul>
<li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li>
<li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li>
</ul>
<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>标记-整理是根据老年代的特点提出的一种标记算法，标记过程与“标记-清除“算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法"></p>
<p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>垃圾收集算法是方法论 垃圾收集器则是垃圾回收的具体实现 它们会使用不同的垃圾回收算法   我们需要根据具体场景选择合适的垃圾收集器。</p>
<p>分类：</p>
<ul>
<li><strong>单线程与多线程：</strong>单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程</li>
<li><strong>串行与并行：</strong>串行是指垃圾收集器与用户程序交替执行，在执行垃圾收集的时候停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。CMS和G1是并行的，其他都是串行。</li>
</ul>
<img src="https://cdn.nlark.com/yuque/0/2022/png/12395513/1657072425889-6c1e10c2-838e-41f5-afaf-f1afc15427e2.png?x-oss-process=image%2Fresize%2Cw_721%2Climit_0" alt="image.png" style="zoom:80%;" />

<h4 id="讲一下CMS收集器"><a href="#讲一下CMS收集器" class="headerlink" title="讲一下CMS收集器"></a>讲一下CMS收集器</h4><p>多线程  <strong>并发</strong>  低停顿   采用标记-清除算法  应用于老年代</p>
<p><strong>以获取最短回收停顿时间为目标</strong> 适用于关注服务响应速度的的服务端虚拟机</p>
<p>分以下四个步骤：</p>
<ol>
<li>初始标记：暂停所有其他线程，记录下与root直接相连的对象，速度很快</li>
<li>并发标记：同时开启GC线程和用户线程，从 GC Roots 的直接关联对象开始遍历整个对象图的过程，<strong>这个过程耗时较长，但是不需要停顿用户线程。</strong></li>
<li>重新标记：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那部分对象的标记记录。这个阶段的停顿时间也很短，但会比初始标记慢一些。</li>
<li>并发清除：清理掉标记的已经死亡的对象，由于不需要移动对象，所以这个阶段也可以和用户线程同时并发。</li>
</ol>
<p>缺点：</p>
<ul>
<li><p>由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生</p>
</li>
<li><p>CMS是一款基于“标记-清除”算法实现的收集器，意味有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况</p>
</li>
</ul>
<h4 id="讲一下G1收集器？有什么缺点？"><a href="#讲一下G1收集器？有什么缺点？" class="headerlink" title="讲一下G1收集器？有什么缺点？"></a>讲一下G1收集器？有什么缺点？</h4><p>G1的特点如下：</p>
<ul>
<li>基于Region的内存布局：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），<strong>每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间</strong>。</li>
<li>Mixed GC的思想：在G1收集器出现之前的所有其他收集器，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），或者整个Java堆（Full GC）。而G1可以面向堆内存任何部分进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大</li>
<li>可预测的时间停顿模型：G1可以由用户自己去设置STW的最大时间，在进行垃圾收集的时候，会根据每个Region<strong>预计垃圾收集所需时间</strong>与<strong>预计回收内存大小</strong>来选择对哪些区域进行回收，优先处理回收价值收益最大的那些Region，从而满足用户设定的目标停顿时间。</li>
</ul>
<p>G1回收的四个步骤：</p>
<ul>
<li>初始标记：标记一下GC Roots能直接关联到的对象</li>
<li>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录。</li>
<li>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12395513/1661341347229-a5749e8e-c5f3-483c-a3d3-8444216b998d.png?x-oss-process=image/resize,w_730,limit_0" alt="image.png"></p>
<h4 id="什么是类加载？何时进行类加载？类加载流程？"><a href="#什么是类加载？何时进行类加载？类加载流程？" class="headerlink" title="什么是类加载？何时进行类加载？类加载流程？"></a>什么是类加载？何时进行类加载？类加载流程？</h4><p>Class文件需要加载到虚拟机中之后才能被运行和使用。</p>
<p>类加载的时机：类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。</p>
<p>类加载的流程：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png" alt="类加载过程"></p>
<p><strong>1.加载</strong></p>
<p>加载过程主要完成三个事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口</li>
</ol>
<p>加载这一步通过<strong>类加载器</strong>来完成，加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定，我们也可以打破双亲委派模型。</p>
<p><strong>2.连接</strong></p>
<p>连接又分验证、准备、解析这三步。。。</p>
<p><strong>3.初始化</strong></p>
<p><strong>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong></p>
<h4 id="知道哪些类加载器？类加载器之间的关系？"><a href="#知道哪些类加载器？类加载器之间的关系？" class="headerlink" title="知道哪些类加载器？类加载器之间的关系？"></a>知道哪些类加载器？类加载器之间的关系？</h4><p><strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong></p>
<p>JVM中内置了三个ClassLoader：</p>
<ol>
<li><strong>BootstrapClassLoader</strong>(启动类加载器)：最顶级的加载器，负责加载%JAVA_HOME%&#x2F;lib目录下的jar包和类或者被Xbootclasspath参数指定的路径中的所有类</li>
<li><strong>ExtensionClassLoader</strong>(扩展类加载器)：主要负责加载%JRE_HOME%&#x2F;lib&#x2F;ext目录下的jar包和类以及被java.ext.dirs系统变量所指定的路径下的所有类</li>
<li><strong>AppClassLoader</strong>(应用程序类加载器)：面向用户的加载器，负责加载当前应用classpath下的所有jar包和类</li>
</ol>
<h4 id="类加载器的双亲委派了解么？Tomcat如何打破双亲委派机制？"><a href="#类加载器的双亲委派了解么？Tomcat如何打破双亲委派机制？" class="headerlink" title="类加载器的双亲委派了解么？Tomcat如何打破双亲委派机制？"></a>类加载器的双亲委派了解么？Tomcat如何打破双亲委派机制？</h4><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom:80%;" />

<p>类加载器的双亲委派机制是指：</p>
<ul>
<li>在类加载的时候，系统首先会<strong>自底向上</strong>判断当前类是否已经被加载过。已经加载过的类会直接返回，否则才会尝试加载</li>
<li>加载的时候，首先会把该请求委派给父类加载器的loadClass()处理，当父类加载器无法处理时，才由自己来处理。</li>
<li>总结：自底向上查找判断类是否被加载过，自顶向下尝试去加载类。</li>
</ul>
<h4 id="双亲委派模型的好处？"><a href="#双亲委派模型的好处？" class="headerlink" title="双亲委派模型的好处？"></a>双亲委派模型的好处？</h4><ul>
<li>避免类重复加载：当父加载器已经加载过某一个类的时候，子加载器就不会再加载这个类</li>
<li>另外，使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而<strong>使得基础类得到统一</strong>。有效的防止核心Java API被篡改， 保证了安全性。</li>
</ul>
<h5 id="为什么Tomcat要破坏双亲委派？"><a href="#为什么Tomcat要破坏双亲委派？" class="headerlink" title="为什么Tomcat要破坏双亲委派？"></a>为什么Tomcat要破坏双亲委派？</h5><ul>
<li>Tomcat是web容器，一个web容器可能需要部署多个应用程序，<strong>主要为不同应用程序提供隔离机制</strong>。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如果采用默认的双亲委派类加载机制，那么是<strong>无法加载多个相同的类。</strong>所以，Tomcat破坏双亲委派原则，<strong>自定义类加载器</strong> 为每个web容器单独提供一个WebAppClassLoader加载器</li>
<li>Tomcat的类加载机制：为了实现隔离性，<strong>优先加载 Web 应用自己定义的类</strong>，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件，<strong>加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反</strong></li>
</ul>
<p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>
<h4 id="JVM常见指令和工具"><a href="#JVM常见指令和工具" class="headerlink" title="JVM常见指令和工具"></a>JVM常见指令和工具</h4><h5 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h5><p>查看java进程</p>
<h5 id="Jconsole"><a href="#Jconsole" class="headerlink" title="Jconsole"></a>Jconsole</h5><p>可以查看java进程的内存使用情况、线程数、加载的类的数量等等信息</p>
<h5 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h5><p>用于监控java进程的内存使用状况以及GC的情况</p>
<h5 id="Jstack"><a href="#Jstack" class="headerlink" title="Jstack"></a>Jstack</h5><p>查看某个java进程内的线程堆栈信息</p>
<h5 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h5><p>通常用于<strong>诊断和调试</strong> Java 应用程序的<strong>内存问题</strong>，例如<strong>内存泄漏</strong>、<strong>内存溢出</strong>等。<br>通过 jmap -heap 命令获取到的堆内存信息可以帮助开发人员更加全面地了解 Java 应用程序的内存使用情况，找出内存问题的根本原因，并进行相应的优化和改进。</p>
<h4 id="怎么排查OOM的情况？"><a href="#怎么排查OOM的情况？" class="headerlink" title="怎么排查OOM的情况？"></a>怎么排查OOM的情况？</h4><ol>
<li>使用jps查看项目进程id。</li>
<li>jstat查看虚拟机运行状态，看看是否频繁发生Full GC</li>
</ol>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2166218/gtgb7de111.png" alt="img"></p>
<ol>
<li>使用jmap dump一份内存快照出来。</li>
<li>使用VisualVM对快照文件进行分析，看一下每个类的实例数量以及内存占用。</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h4><ul>
<li>InnoDB支持行级锁，MyISAM只支持表级锁</li>
<li>InnoDB支持事务，MyISAM不支持</li>
<li>InnoDB支持MVCC，MyISAM不支持</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
</ul>
<h4 id="说一说一条查询语句在MYSQL中的执行流程？"><a href="#说一说一条查询语句在MYSQL中的执行流程？" class="headerlink" title="说一说一条查询语句在MYSQL中的执行流程？"></a>说一说一条查询语句在MYSQL中的执行流程？</h4><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程" style="zoom:80%;" />

<p>执行一条SQL查询语句发生的动作：</p>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回结果</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h4 id="char-和-varchar-的区别是什么？"><a href="#char-和-varchar-的区别是什么？" class="headerlink" title="char 和 varchar 的区别是什么？"></a>char 和 varchar 的区别是什么？</h4><p>CHAR和VARCHAR是最常用的字符串类型，两者主要的区别是：CHAR是定长字符串，VARCHAR是变长字符串。</p>
<p>CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</p>
<p>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</p>
<p>CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</p>
<h4 id="索引的优缺点？"><a href="#索引的优缺点？" class="headerlink" title="索引的优缺点？"></a>索引的优缺点？</h4><p><strong>优点：</strong></p>
<ul>
<li>能够快速定位数据，加快查询</li>
<li>将随机I&#x2F;O变为顺序I&#x2F;O：B+Tree的索引是有序的，会把相邻的数据都存储在一起</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引需要占物理空间</li>
<li>对于DML操作还要去维护索引，降低操作速度</li>
</ul>
<h4 id="聚集索引和⾮聚集索引的区别？⾮聚集索引⼀定回表查询吗"><a href="#聚集索引和⾮聚集索引的区别？⾮聚集索引⼀定回表查询吗" class="headerlink" title="聚集索引和⾮聚集索引的区别？⾮聚集索引⼀定回表查询吗?"></a>聚集索引和⾮聚集索引的区别？⾮聚集索引⼀定回表查询吗?</h4><p>聚集索引：索引结构和数据一起存放的索引。主键索引属于聚集索引。</p>
<p><strong>提问：主键索引一定是聚簇索引吗？</strong></p>
<ol>
<li>如果这张表定义了主键索引，那么主键索引就是聚簇索引</li>
<li>如果没有定义主键索引，那么该表的第一个唯一非空索引作为聚集索引。</li>
<li>如果没有唯一非空索引，那么 InnoDB 内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个 6 个字节的列，该列的值会随着数据的插入自增。</li>
</ol>
<p>非聚集索引：索引结构和数据分开存放的索引</p>
<ul>
<li>叶子节点不包含行记录的所有数据，而是存放主键值</li>
</ul>
<p>由于非聚集索引的叶子节点没有存放全部数据，因此如果查找的字段不在非聚集索引中时，需要进行回表查询，也就是去聚集索引中查找数据，但如果索引覆盖到了所有需要查询的字段，那么就不需要回表查询，此时该索引被称为“覆盖索引”。</p>
<h4 id="索引这么多优点，为什么不对表中的每⼀个列创建⼀个索引呢？"><a href="#索引这么多优点，为什么不对表中的每⼀个列创建⼀个索引呢？" class="headerlink" title="索引这么多优点，为什么不对表中的每⼀个列创建⼀个索引呢？"></a>索引这么多优点，为什么不对表中的每⼀个列创建⼀个索引呢？</h4><p>索引也有缺点：</p>
<ol>
<li>索引需要占物理空间</li>
<li>在执行DML语句的时候需要去维护索引，降低操作的速度</li>
</ol>
<p>同时索引也并非一定能提升查询性能：</p>
<ol>
<li>使用非聚集索引有时候需要回表查询</li>
<li>如果索引的选择性很低的话走索引不一定比全表扫描快(选择性&#x3D;基数&#x2F;行数；基数是字段不同值的数量)</li>
</ol>
<h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h4><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code><strong>、</strong><code>&lt;</code></strong> ）才会停止匹配。</p>
<h4 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h4><ol>
<li><p><strong>使用like进行左或左右模糊匹配：</strong> **like %xx 或者like %xx%**，因为排序的时候是按前缀比较的</p>
</li>
<li><p>范围查询(&gt;、&lt;、between)</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12395513/1655430610802-ca0af4b8-a48d-4d36-8737-597136e08f11.png" alt="image.png"></p>
</li>
<li><p><strong>mysql在使用不等于（！&#x3D;或者&lt;&gt;）的时候有可能失效</strong></p>
</li>
<li><p><strong>对索引使用函数或者进行计算</strong> </p>
<ul>
<li>例如： select * from t_user where length(name)&#x3D;6;</li>
<li>因为索引保存的是索引字段的原始值 而不是经过函数计算后的值</li>
</ul>
</li>
<li><p><strong>联合索引不满足最左匹配原则</strong></p>
</li>
<li><p><strong>where子句中使用OR  且有一个不是索引列</strong></p>
</li>
<li><p><strong>类型隐式转换</strong></p>
<ul>
<li>例如：select * from t_user where id_no &#x3D; 1002;  id_no字段类型为varchar，但在SQL语句中使用了int类型，导致全表扫描。</li>
</ul>
</li>
</ol>
<h4 id="唯一索引和主键索引区别？唯一索引可以空吗？主键索引可以空吗？"><a href="#唯一索引和主键索引区别？唯一索引可以空吗？主键索引可以空吗？" class="headerlink" title="唯一索引和主键索引区别？唯一索引可以空吗？主键索引可以空吗？"></a>唯一索引和主键索引区别？唯一索引可以空吗？主键索引可以空吗？</h4><p>唯一索引和主键索引在MySQL中有一些区别，包括是否允许为空和是否可以有重复值。</p>
<ol>
<li>唯一索引（Unique Index）：<ul>
<li>唯一索引允许为空值，即可以在索引列中存储NULL值。</li>
<li>唯一索引可以用来保证数据表中某列的值是唯一的。</li>
</ul>
</li>
<li>主键索引<ul>
<li>主键索引不允许为空值，即主键列不能为空</li>
<li>主键索引是聚集索引，叶节点存放的是完整的数据记录</li>
</ul>
</li>
</ol>
<h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h4><p>事务具有ACID四大特性：</p>
<ul>
<li><strong>原子性(Atomincity)：</strong>事务被视为不可分割的最小单元，事务的所有操作要么全部成功，要么全部失败</li>
<li><strong>一致性(Consistency)：</strong>执行事务前后，数据保持一致性</li>
<li><strong>隔离性(Isolation)：</strong>一个事务所做的修改在最终提交以前，对其他事务是不可见的。隔离性可以防止多个事务并发执行时由于交叉执行而导致的数据不一致。</li>
<li><strong>持久性(Durability)：</strong>一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障，事务执行的结果也不能丢失。</li>
</ul>
<h4 id="事务的实现原理？-对应ACID特性"><a href="#事务的实现原理？-对应ACID特性" class="headerlink" title="事务的实现原理？(对应ACID特性)"></a>事务的实现原理？(对应ACID特性)</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><ul>
<li>在异常发生时，对已经执行的操作进行回滚。通过 <strong>回滚日志（undo log）</strong> 实现的：所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 回滚日志 中的信息将数据回滚到修改之前的样子即可</li>
<li>并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</li>
</ul>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><ul>
<li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障</li>
</ul>
<h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><ul>
<li>通过锁机制、MVCC来保证事务的隔离性(默认支持的隔离级别是REPEATABLE-READ)</li>
</ul>
<h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h5><ul>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的持久性</li>
<li>MySQL中的Write Ahead Logging技术的关键点就是先写到日志redo log 选择合适的时间将数据写到磁盘</li>
<li>数据页和undo log页都是通过redo log来持久化到磁盘</li>
</ul>
<p><strong>总结：</strong></p>
<p>原子性由undo log来保证</p>
<p>持久性由redo log保证</p>
<p><img src="/image-20240305231505465.png" alt="image-20240305231505465"></p>
<h4 id="并发事务一致性的问题"><a href="#并发事务一致性的问题" class="headerlink" title="并发事务一致性的问题"></a>并发事务一致性的问题</h4><p>并发事务的一致性问题主要是破坏了事务的隔离性导致的</p>
<h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>一个事务读取了另一个事务未提交的数据</p>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>某一个事务对同一数据前后读取的结果不一致</p>
<h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><p>某一个事务对同一张表前后查询到的行数不一致（发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读）</p>
<h5 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h5><ul>
<li>不可重复读的重点在于修改，比如多次读取一条记录发现其中某些列的值被修改</li>
<li>幻读的重点在于新增或者删除，比如多次执行同一条DQL语句，发现查找出的记录多了或者少了</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取已提交) ，但是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重复读） 且不会有任何性能损失。</p>
<h5 id="读取未提交"><a href="#读取未提交" class="headerlink" title="读取未提交"></a>读取未提交</h5><ul>
<li>最低的隔离级别，<strong>允许读取尚未提交的数据变更</strong>，可能会导致脏读、幻读或不可重复读。</li>
<li>实现：不加任何锁</li>
</ul>
<h5 id="读取已提交"><a href="#读取已提交" class="headerlink" title="读取已提交"></a>读取已提交</h5><ul>
<li>允许读取并发事务已经提交的数据，可以阻止脏读，<strong>但是幻读或不可重复读仍有可能发生。</strong></li>
<li>实现：MVCC</li>
</ul>
<h5 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h5><ul>
<li>(MySQL的默认隔离级别)   同一数据的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</li>
<li>实现：MVCC</li>
</ul>
<h5 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h5><ul>
<li>最高的隔离级别，完全服从 ACID 的隔离级别。<strong>所有的事务依次逐个执行</strong>，这样事务之间就完全不可能产生干扰，可以防止脏读、不可重复读以及幻读。</li>
<li>实现：读的时候加共享<strong>锁</strong>，写的时候加排它锁。</li>
</ul>
<img src="https://cdn.nlark.com/yuque/0/2022/png/12395513/1657679756128-8d71285a-5e1d-4d8f-9a2d-ac25d9ed88fa.png" alt="image.png" style="zoom:67%;" />

<h4 id="MySQL-的隔离级别是基于锁实现的吗"><a href="#MySQL-的隔离级别是基于锁实现的吗" class="headerlink" title="MySQL 的隔离级别是基于锁实现的吗"></a>MySQL 的隔离级别是基于锁实现的吗</h4><p>是基于锁和MVCC(并发多版本控制)实现的。</p>
<p>MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。</p>
<p>通俗的讲就是MVCC通过保存数据的历史版本，根据比较数据的版本号来决定数据的是否显示，在不需要加读锁的情况就能达到事务的隔离效果，最终可以在读取数据的时候可以同时进行修改，修改数据时候可以同时读取，极大的提升了事务的并发性能。</p>
<p>对于普通读操作会生成一个视图，读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。</p>
<p>当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。</p>
<p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p>
<ul>
<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li>
<li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li>
</ul>
<h4 id="MVCC的原理"><a href="#MVCC的原理" class="headerlink" title="MVCC的原理"></a>MVCC的原理</h4><p>MVCC：多版本并发控制，指的是维护一个数据的多个版本，使得读写之间没有冲突，可以实现非阻塞读的功能。MVCC的具体实现，还依赖于数据库记录中的隐式字段、undo log日志、readView。</p>
<p>数据库记录的隐藏字段包括最近修改事务ID和回滚指针，回滚指针会指向这条记录的上一个版本，配合undo log实现一条版本链，版本链中保存了修改数据的事务ID以及修改的值，按修改顺序排列。当SQL执行快照读时会沿着版本链进行匹配，查找出满足条件的记录进行显示。</p>
<h4 id="RR隔离级别下怎么解决幻读？"><a href="#RR隔离级别下怎么解决幻读？" class="headerlink" title="RR隔离级别下怎么解决幻读？"></a>RR隔离级别下怎么解决幻读？</h4><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p>
<p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p>
<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p>
<p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p>
<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <code>Next-key Lock</code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>
<h4 id="MySQL的binlog主要记录什么"><a href="#MySQL的binlog主要记录什么" class="headerlink" title="MySQL的binlog主要记录什么"></a>MySQL的binlog主要记录什么</h4><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的逻辑日志。作用：</p>
<ul>
<li>MySQL的数据备份、主从复制都依赖于binlog</li>
</ul>
<h4 id="redo-log如何保证事务的持久性"><a href="#redo-log如何保证事务的持久性" class="headerlink" title="redo log如何保证事务的持久性"></a>redo log如何保证事务的持久性</h4><p>redo log 是物理日志，记录了某个数据页做了什么修改。</p>
<p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p>
<p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<h4 id="bin-log和redo-log有什么区别"><a href="#bin-log和redo-log有什么区别" class="headerlink" title="bin log和redo log有什么区别"></a>bin log和redo log有什么区别</h4><ol>
<li><strong>适用对象不同：</strong><ul>
<li>binlog是MySQL的Server层实现的日志，所有存储引擎都可以使用；</li>
<li>redo log是Innodb存储引擎实现的日志</li>
</ul>
</li>
<li><strong>记录内容不同：</strong><ul>
<li>binlog是逻辑日志，记录内容是语句的原始逻辑</li>
<li>redo log是物理日志，记录的是在某个数据页做了什么修改</li>
</ul>
</li>
<li><strong>写入方式不同：</strong><ul>
<li>binlog是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li>
<li>redo log是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li>
</ul>
</li>
<li><strong>用途不同：</strong><ul>
<li>binlog用于备份恢复、主从复制；</li>
<li>redo log用于掉电等故障恢复</li>
</ul>
</li>
</ol>
<h4 id="undo-log有什么用？"><a href="#undo-log有什么用？" class="headerlink" title="undo log有什么用？"></a>undo log有什么用？</h4><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E7%89%88%E6%9C%AC%E9%93%BE.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="版本链" style="zoom:80%;" />

<p>undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）。</p>
<p>undo log 两大作用：</p>
<ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li>
<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li>
</ul>
<h4 id="一条更新语句在MYSQL中的执行过程"><a href="#一条更新语句在MYSQL中的执行过程" class="headerlink" title="一条更新语句在MYSQL中的执行过程"></a>一条更新语句在MYSQL中的执行过程</h4><p><img src="https://img-blog.csdnimg.cn/cc1118ba231242428b11d75ee50ce38f.png" alt="在这里插入图片描述"></p>
<p>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit)状态</p>
<p>这里redo log和bin log的两阶段提交机制主要是为了保证redo log和bin log的逻辑一致性。</p>
<h4 id="如何分析SQL的性能"><a href="#如何分析SQL的性能" class="headerlink" title="如何分析SQL的性能"></a>如何分析SQL的性能</h4><p>可以使用<code>explain</code>命令来分析SQL的执行计划。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p>
<p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>
<h4 id="有哪些常见的SQL优化手段"><a href="#有哪些常见的SQL优化手段" class="headerlink" title="有哪些常见的SQL优化手段"></a>有哪些常见的SQL优化手段</h4><h5 id="1-避免使用select"><a href="#1-避免使用select" class="headerlink" title="1.避免使用select *"></a>1.避免使用select *</h5><h5 id="2-优化深度分页"><a href="#2-优化深度分页" class="headerlink" title="2.优化深度分页"></a>2.优化深度分页</h5><p>当数据表比较大时分页查询是比较耗时的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score,name <span class="keyword">FROM</span> cus_order <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span> LIMIT <span class="number">1000000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>改写查询条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score,name <span class="keyword">FROM</span> cus_order <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span> <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1000000</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-优化慢SQL"><a href="#3-优化慢SQL" class="headerlink" title="3.优化慢SQL"></a>3.优化慢SQL</h5><p>查询慢查询日志，得到慢SQL</p>
<p>explain一下慢SQL的执行计划然后对应去优化</p>
<h5 id="4-正确使用索引"><a href="#4-正确使用索引" class="headerlink" title="4.正确使用索引"></a>4.正确使用索引</h5><h5 id="5-联表的时候小表在前"><a href="#5-联表的时候小表在前" class="headerlink" title="5.联表的时候小表在前"></a>5.联表的时候小表在前</h5><h5 id="6-联表不要太多"><a href="#6-联表不要太多" class="headerlink" title="6.联表不要太多"></a>6.联表不要太多</h5><h4 id="读写分离？"><a href="#读写分离？" class="headerlink" title="读写分离？"></a>读写分离？</h4><p><strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png" alt="读写分离示意图"></p>
<p>实现读写分离一般包含如下几步：</p>
<ol>
<li>部署多台数据库，选择其中的一台作为主数据库，其他的作为从数据库</li>
<li>保证主数据库与从数据库之间的数据同步，这个过程一般通过<strong>主从复制</strong>实现</li>
<li>系统将写请求交给主数据库处理，读请求交给从数据库处理</li>
</ol>
<h5 id="主从复制的原理是什么？"><a href="#主从复制的原理是什么？" class="headerlink" title="主从复制的原理是什么？"></a>主从复制的原理是什么？</h5><p><img src="https://img-blog.csdnimg.cn/20201204140551526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FzYWFzYTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>主从复制的步骤：</p>
<ol>
<li>Master的写操作会记录在binlog中，当Slave连接到Master后，Master会开启binlog dump线程，该线程回去读取bin log日志</li>
<li>Slave连接到Master后，Slave库有一个I&#x2F;O线程通过请求binlog dump thread读取bin log日志，然后写入到从库的relay log中</li>
<li>Slave中有一个SQL Thread，复制监控relay log，将relay log的内容进行重放，实现主从库数据复制</li>
</ol>
<h5 id="主从复制带来的问题：主从延迟"><a href="#主从复制带来的问题：主从延迟" class="headerlink" title="主从复制带来的问题：主从延迟"></a>主从复制带来的问题：主从延迟</h5><p>由于Mysql主从复制默认采取异步操作，即主库写入binlog之后直接返回，binlog传递给从库的过程主库并不关心，这就导致如果Master和Slave之间有网络延迟，就会造成暂时的数据不一致的现象；如果Master出故障，而数据还没有复制过去，则会造成数据丢失。</p>
<p>这里应该根据系统的实际情况去选择主从复制的策略，如果对主从延迟零容忍则应采取同步主从复制的方式，但一般来说都是采用异步方式。</p>
<h4 id="分库分表？"><a href="#分库分表？" class="headerlink" title="分库分表？"></a>分库分表？</h4><p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。但如果数据库中存储数据量过大应该怎么办？</p>
<p>解决方式之一为<strong>分库分表</strong></p>
<h5 id="什么是分库？"><a href="#什么是分库？" class="headerlink" title="什么是分库？"></a>什么是分库？</h5><p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>
<p><strong>垂直分库</strong> 就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p>
<p><strong>水平分库</strong> 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p>
<h5 id="什么是分表？"><a href="#什么是分表？" class="headerlink" title="什么是分表？"></a>什么是分表？</h5><p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<p><strong>垂直分表</strong> 是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p><strong>水平分表</strong> 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis这里主要要掌握的问题：</p>
<ol>
<li>redis的线程模型</li>
<li>redis使用场景相关(大key、热key、redis实现分布式锁…)</li>
<li>redis持久化</li>
<li>redis高可用(集群…)</li>
<li>缓存的使用方法、更新策略…</li>
</ol>
<h4 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h4><ul>
<li>数据结构<strong>存储在内存中</strong>，大部分请求都是纯粹的内存操作</li>
<li><strong>使用简单灵活的数据结构</strong>，提供高性能的读取和写入</li>
<li><strong>采用单线程，</strong>省去了上下文切换的时间，不存在竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，也不会出现死锁而导致的性能消耗。</li>
<li><strong>使用IO多路复用模型处理大量的客户端 Socket 请求</strong>，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。</li>
</ul>
<h4 id="Redis是单线程的吗？"><a href="#Redis是单线程的吗？" class="headerlink" title="Redis是单线程的吗？"></a>Redis是单线程的吗？</h4><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p>
<p>但是Redis程序并不是单线程的，还存在有后台线程。</p>
<p> Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p>
<p>Redis6.0版本后  对于<strong>网络IO</strong>采用多线程来处理 但是命令的执行依旧是单线程</p>
<h4 id="为什么Redis采用单线程？单线程为什么还快？"><a href="#为什么Redis采用单线程？单线程为什么还快？" class="headerlink" title="为什么Redis采用单线程？单线程为什么还快？"></a>为什么Redis采用单线程？单线程为什么还快？</h4><ul>
<li><p>Redis处理的请求一般都是简单的读写操作，不涉及复杂的计算，同时Redis 的大部分操作都在<strong>内存</strong>中进行，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 <strong>CPU 不是瓶颈，</strong>所以没必要使用多线程</p>
</li>
<li><p><strong>避免了多线程切换</strong>带来的时间和性能上的开销，而且也不会导致死锁问题。</p>
</li>
<li><p>Redis 采用了 <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，一个线程处理多个 IO 流，就是我们经常说的 select&#x2F;epoll 机制。在 Redis 只运行单线程的情况下，IO多路复用机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>
</li>
</ul>
<h4 id="Redis常见数据结构及使用场景"><a href="#Redis常见数据结构及使用场景" class="headerlink" title="Redis常见数据结构及使用场景"></a>Redis常见数据结构及使用场景</h4><p>Redis键的类型只能为字符串String</p>
<p>值支持五种常用的数据类型：</p>
<ul>
<li>字符串 STRING</li>
<li>列表 LIST</li>
<li>集合 SET</li>
<li>散列表 HASH</li>
<li>有序集合 ZSET</li>
</ul>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <code>512M</code>。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/string.png" alt="img"></p>
<p><strong>使用场景：</strong></p>
<ol>
<li>缓存对象</li>
<li>计数器</li>
<li>分布式锁</li>
</ol>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>List 列表是简单的字符串列表，<strong>按照插入顺序排序</strong>，可以从头部或尾部向 List 列表添加元素。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/list.png" alt="img"></p>
<p><strong>使用场景：</strong></p>
<p>消息队列</p>
<h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>Hash 是一个键值对（key - value）集合，其中 value 的形式如： <code>value=[&#123;field1，value1&#125;，...&#123;fieldN，valueN&#125;]</code>。Hash 特别适合用于存储对象。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/hash.png" alt="img"></p>
<p><strong>使用场景：</strong></p>
<p>一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储，比如购物车这种</p>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/set.png" alt="img"></p>
<p>Set 类型和 List 类型的区别如下：</p>
<ul>
<li>List 可以存储重复元素，Set 只能存储非重复元素；</li>
<li>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。</li>
</ul>
<p><strong>使用场景：</strong></p>
<p>关注、点赞等场景，一个用户所有的关注人可以放在一个集合，求共同关注的话就对两个集合求并集。对文章点赞的用户也可以放在一个集合里面。</p>
<h5 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h5><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/zset.png" alt="img"></p>
<p>应用场景：</p>
<p><strong>排行榜：</strong>比如文章点赞量排行，粉丝关注时间排行等。</p>
<h4 id="为什么用Redis而不是本地内存？"><a href="#为什么用Redis而不是本地内存？" class="headerlink" title="为什么用Redis而不是本地内存？"></a>为什么用Redis而不是本地内存？</h4><ol>
<li><strong>多机器缓存一致性</strong>：Redis实现的是分布式缓存，如果有多台实例(机器)的话，<strong>每个实例都共享一份缓存</strong>，缓存具有一致性。</li>
<li><strong>持久化与容灾能力</strong>：Redis是专业的缓存软件，可以用几十个G内存来做缓存。Redis一般用作于缓存，可以将缓存数据保存在硬盘中，Redis重启了后可以将其恢复。原生提供丰富的数据结构、缓存过期机制等等简单好用的功能。</li>
</ol>
<h4 id="大Key问题？"><a href="#大Key问题？" class="headerlink" title="大Key问题？"></a>大Key问题？</h4><p>大Key并不是指key的值很大，而是key对应的value很大。</p>
<p>一般而言，下面这两种情况被称为大 key：</p>
<ul>
<li>String 类型的值大于 10 KB；</li>
<li>Hash、List、Set、ZSet 类型的元素的个数超过 5000个；</li>
</ul>
<h5 id="大key有什么问题？"><a href="#大key有什么问题？" class="headerlink" title="大key有什么问题？"></a>大key有什么问题？</h5><p>大 key 会带来以下四种影响：</p>
<ul>
<li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
</ul>
<h5 id="如何查找大key？"><a href="#如何查找大key？" class="headerlink" title="如何查找大key？"></a>如何查找大key？</h5><ul>
<li>redis-cli –bigkeys 查找大key<ul>
<li>只能找到最大的哪一个bigkey</li>
<li>对于集合类型，统计的是元素个数多少，而非内存占用</li>
</ul>
</li>
<li>使用SCAN命令</li>
<li>使用RdbTools工具查找</li>
</ul>
<h5 id="如何删除大key？"><a href="#如何删除大key？" class="headerlink" title="如何删除大key？"></a>如何删除大key？</h5><ul>
<li>分批次删除</li>
<li>异步删除(unlink命令，放入一个异步线程中去删除)</li>
</ul>
<h5 id="如何解决大key问题？"><a href="#如何解决大key问题？" class="headerlink" title="如何解决大key问题？"></a>如何解决大key问题？</h5><ul>
<li>对大key进行拆分：在设计阶段就把大key拆分成一个一个小key</li>
<li>对大key进行清理：定时检查Redis是否存在大key，如果该大 key 是可以删除的，不要使用 DEL 命令删除，因为该命令删除过程会阻塞主线程，而是用 unlink 命令（Redis 4.0+）删除大 key，因为该命令的删除过程是异步的，不会阻塞主线程。</li>
<li>压缩value</li>
</ul>
<h4 id="热Key问题"><a href="#热Key问题" class="headerlink" title="热Key问题"></a>热Key问题</h4><h5 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h5><p>突然有大量的请求去访问redis上的某一个特定key   这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis服务器宕机   那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。—-也属于缓存击穿？</p>
<h5 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h5><ul>
<li>二级缓存<ul>
<li>比如利用本地缓存，在发现热key后，把热key加载到系统的本地缓存中，针对这种热key请求，会直接从jvm中取，而不会走到redis层。</li>
</ul>
</li>
<li>备份热key<ul>
<li>不让key走到同一台redis上。我们把这个key，在多个redis上都存一份，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。</li>
</ul>
</li>
</ul>
<h4 id="说一下AOF持久化"><a href="#说一下AOF持久化" class="headerlink" title="说一下AOF持久化"></a>说一下AOF持久化</h4><p>AOF是redis持久化的一种方式，这个方法是每执行一条写操作命令，就将该命令以追加的方式写入到 AOF 文件，然后在重启时，以逐一执行命令的方式来进行数据恢复。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/28afd536c57a46447ddab0a2062abe84.png" alt="img" style="zoom:67%;" />

<p>这里写日志操作与执行命令是同步的，因此该IO操作有可能会阻塞住，因此对于AOF日志何时写入硬盘，Redis提供了三种写入策略：A</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a.png" alt="img" style="zoom:80%;" />

<p>AOF日志文件随着写操作命令增加，文件越来越大，达到一个阈值时会执行AOF日志重写机制，AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>AOF日志重写可能比较耗时，这个过程由后台子进程去完成。主进程调用fork()创建子进程操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两个进程此时共享物理内存。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/5a1f2a90b5f3821c19bea3b7a5f27fa1.png" alt="img" style="zoom:80%;" />

<p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p>
<p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作，这个过程被称为「**写时复制(*Copy On Write*)**」。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/d4cfac545377b54dd035c775603b4936.png" alt="img" style="zoom:80%;" />

<p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p>
<p>如果此时<strong>主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的</strong>。</p>
<p>重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p>
<p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p>
<p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p>
<img src="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309231944807.png" alt="在这里插入图片描述" style="zoom:67%;" />

<p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ul>
<p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p>
<ul>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li>
<li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li>
</ul>
<p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p>
<h4 id="说一下RDB持久化"><a href="#说一下RDB持久化" class="headerlink" title="说一下RDB持久化"></a>说一下RDB持久化</h4><p>通过<strong>创建快照</strong>来获取内存数据在某个时间点上的副本。 在创建快照之后，用户可以对快照进行备份（如果系统真的发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。）</p>
<p>开启自动持久化后，Redis 会将某一时刻的内存数据以二进制形式写入到磁盘里。数据会存储到默认名为<code>**dump.rdb**</code>的文件中。当 Redis 服务器重启时，检测到<code>dump.rdb</code>文件后，会自动加载进行数据恢复</p>
<p>RDB持久化也是用后台子进程做的，在执行RDB快照的时候主进程想要修改的话也是通过COW写时复制的方式，只不过RDB不会像AOF那样把改的数据给记下来。</p>
<h4 id="比较一下RDB和AOF？"><a href="#比较一下RDB和AOF？" class="headerlink" title="比较一下RDB和AOF？"></a>比较一下RDB和AOF？</h4><ul>
<li><strong>恢复速度</strong>：RDB的恢复速度快一点，加载 RDB 文件速度很快，而AOF需要依次读取并执行操作命令。</li>
<li><strong>文件体积：</strong>RDB采用二进制格式存储，比AOF文件体积小一点</li>
<li><strong>数据完整性：</strong>AOF的数据是及时写入的，数据保存更完整。RDB是某一时刻的快照，无法保存最近一次快照之后的数据。</li>
</ul>
<h4 id="缓存读写策略？"><a href="#缓存读写策略？" class="headerlink" title="缓存读写策略？"></a>缓存读写策略？</h4><h5 id="Cache-Aside-Pattern-旁路缓存"><a href="#Cache-Aside-Pattern-旁路缓存" class="headerlink" title="Cache Aside Pattern(旁路缓存)"></a>Cache Aside Pattern(旁路缓存)</h5><p>旁路缓存模式下服务端需要同时维系数据库和缓存，以数据库的数据为准。</p>
<p><strong>写：</strong></p>
<ol>
<li>先更新数据库</li>
<li>直接删除缓存</li>
</ol>
<img src="image-20240225144453646.png" alt="image-20240225144453646" style="zoom:67%;" />

<p><strong>读：</strong></p>
<ol>
<li>从cache中读取数据，读取到就直接返回</li>
<li>cache中读取不到数据的话从db中读取数据返回</li>
<li>把db中读取到的数据放到cache中</li>
</ol>
<img src="image-20240225151655223.png" alt="image-20240225151655223" style="zoom:80%;" />

<h4 id="缓存与数据库的一致性问题"><a href="#缓存与数据库的一致性问题" class="headerlink" title="缓存与数据库的一致性问题"></a>缓存与数据库的一致性问题</h4><p>这里主要讨论一下Cache Aside Pattern策略下的缓存与数据库一致性的问题，一般来说，缓存与数据库之间并不能保证强一致性，只能保证最终一致性，因为保证强一致性可能需要把对缓存和数据库的修改合并成一个原子操作，在修改数据时阻塞其他线程，或者采用一些分布式一致性协议去保证二者之间的一致性，这样无疑会降低整个数据访问系统的性能，本来加缓存就是为了提高性能的，保证强一致性可能会得不偿失。下面讨论一些更新缓存和数据库的方案。</p>
<h5 id="先更新数据库，后更新缓存-不推荐"><a href="#先更新数据库，后更新缓存-不推荐" class="headerlink" title="先更新数据库，后更新缓存(不推荐)"></a>先更新数据库，后更新缓存(不推荐)</h5><p>假设我们采用「先更新数据库，再更新缓存」的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？</p>
<p>有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：</p>
<ol>
<li>线程 A 更新数据库（X &#x3D; 1）</li>
<li>线程 B 更新数据库（X &#x3D; 2）</li>
<li>线程 B 更新缓存（X &#x3D; 2）</li>
<li>线程 A 更新缓存（X &#x3D; 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。</p>
<p>也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。</p>
<p>同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。</p>
<p>所以此时我们需要考虑另外一种方案：<strong>删除缓存</strong>。</p>
<h5 id="先删除缓存，后更新数据库-不推荐"><a href="#先删除缓存，后更新数据库-不推荐" class="headerlink" title="先删除缓存，后更新数据库(不推荐)"></a>先删除缓存，后更新数据库(不推荐)</h5><p>如果先删除缓存，再更新数据库的话，在读写并发的情况下同样存在问题。</p>
<p>如果有 2 个线程要并发「读写」数据，可能会发生以下场景：</p>
<ol>
<li>线程 A 要更新 X &#x3D; 2（原值 X &#x3D; 1）</li>
<li>线程 A 先删除缓存</li>
<li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X &#x3D; 1）</li>
<li>线程 A 将新值写入数据库（X &#x3D; 2）</li>
<li>线程 B 将旧值写入缓存（X &#x3D; 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p>
<h5 id="先更新数据库，后删除缓存-推荐使用"><a href="#先更新数据库，后删除缓存-推荐使用" class="headerlink" title="先更新数据库，后删除缓存(推荐使用)"></a>先更新数据库，后删除缓存(推荐使用)</h5><p>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。但此时还有一个问题，如果删缓存失败怎么办？</p>
<p>解决方案用两个字总结：<strong>重试</strong></p>
<p>重试分同步重试和异步重试，同步重试方案其实不太好，理由如下：</p>
<ul>
<li>立即重试很大概率「还会失败」</li>
<li>「重试次数」设置多少才合理？</li>
<li>重试会一直「占用」这个线程资源，无法服务其它客户端请求</li>
</ul>
<p>因此我们可以采用异步重试的方法，重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。</p>
<p>如果不想在应用中去写消息队列，可以采用以下方案：<strong>订阅数据库变更日志，再操作缓存</strong>。</p>
<p>具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。</p>
<p>那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。</p>
<p>拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。</p>
<img src="https://pic4.zhimg.com/80/v2-545476a6f045750c2a0452c290cb2397_720w.webp" alt="img" style="zoom: 67%;" />

<p>订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：</p>
<ul>
<li><strong>无需考虑写消息队列失败情况</strong>：只要写 MySQL 成功，Binlog 肯定会有</li>
<li><strong>自动投递到下游队列</strong>：canal 自动把数据库变更日志「投递」给下游的消息队列</li>
</ul>
<p>至此，我们可以得出结论，想要保证数据库和缓存一致性，<strong>推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做</strong>。</p>
<h5 id="主从库延迟和延迟双删问题"><a href="#主从库延迟和延迟双删问题" class="headerlink" title="主从库延迟和延迟双删问题"></a>主从库延迟和延迟双删问题</h5><p>在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：</p>
<ol>
<li>线程 A 更新主库 X &#x3D; 2（原值 X &#x3D; 1）</li>
<li>线程 A 删除缓存</li>
<li>线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X &#x3D; 1）</li>
<li>从库「同步」完成（主从库 X &#x3D; 2）</li>
<li>线程 B 将「旧值」写入缓存（X &#x3D; 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。</p>
<p>最有效的办法就是，<strong>把缓存删掉</strong>。</p>
<p>但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：<strong>缓存延迟双删策略</strong>。</p>
<p>线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。</p>
<p>但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？</p>
<ul>
<li>问题1：延迟时间要大于「主从复制」的延迟时间</li>
<li>问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间</li>
</ul>
<p>但是，<strong>这个时间在分布式和高并发场景下，其实是很难评估的。</strong></p>
<p>很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。</p>
<p>所以你看，采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。</p>
<p>所以实际使用中，还是建议采用「先更新数据库，再删除缓存」的方案，同时，要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。</p>
<h4 id="讲一下缓存穿透问题"><a href="#讲一下缓存穿透问题" class="headerlink" title="讲一下缓存穿透问题"></a>讲一下缓存穿透问题</h4><h5 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述：</strong></h5><p>查询根本不存在的数据，使请求直接到达存储层，导致数据库负载过大，甚至宕机</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>缓存空对象<ul>
<li>存储层未命中仍然将空值存入缓存。再次访问该数据缓存直接返回空值<ul>
<li>可以解决无效key变化不频繁的情况  若无效key变化频繁  会导致redis缓存大量无效key 因此尽量将无效key的过期时间设置的短一点（如1分钟）</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤器<ul>
<li>将所有存在的key提前存入布隆过滤器，在访问缓存层之前，先通过布隆过滤器拦截，若请求key不存在与布隆过滤器中，则直接返回空值  存在采取缓存和数据库查询</li>
<li>布隆过滤器的特点：<ul>
<li>一个元素如果判断结果为存在的时候元素不一定存在，但判断为不存在的时候元素一定不存在</li>
<li>布隆过滤器可以添加元素，但不能删除元素，删掉元素会导致误判率增加</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="布隆过滤器原理及实现"><a href="#布隆过滤器原理及实现" class="headerlink" title="布隆过滤器原理及实现"></a>布隆过滤器原理及实现</h4><p>布隆过滤器是一种空间效率很高的随机数据结构，它利用位数组和哈希函数来判断一个元素是否存在于集合中，主要用于在大规模数据中判断一个元素是否存在。</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>布隆过滤器基于一个位数组和若干个哈希函数，其中位数组是一个由0和1组成的数组，初始值全部为0。当一个元素加入到布隆过滤器中时，会通过多个哈希函数生成多个哈希值，然后将这些哈希值对应的位数组位置设置为1。当一个元素要查询是否存在于布隆过滤器中时，也会通过多个哈希函数生成多个哈希值，然后查询这些哈希值对应的位数组位置是否都为1。如果任何一个位数组位置不为1，那么该元素肯定不存在于布隆过滤器中。如果所有位数组位置都为1，那么该元素可能存在于布隆过滤器中。因为多个元素可能会被哈希到同一个位数组位置上，所以存在误判的情况，但是不会漏掉任何一个元素。</p>
<p><img src="https://pics1.baidu.com/feed/2e2eb9389b504fc231c6e024ac4e141a91ef6d91.jpeg@f_auto?token=f6189f00209eddf647fc3570ef15def2" alt="img"></p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>布隆过滤器相比其他数据结构有如下优点：</p>
<ul>
<li><strong>空间效率高</strong>：布隆过滤器只需要一个位数组和若干个哈希函数，所以它的空间效率很高。</li>
<li><strong>查询效率高</strong>：布隆过滤器的查询效率非常高，因为它只需要对位数组进行查询，而不需要真正的查询数据。</li>
<li><strong>可扩展性强</strong>：布隆过滤器可以根据需要动态调整位数组大小。</li>
</ul>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>Google 的 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Guava&spm=1001.2101.3001.7020">Guava</a> 库提供了使用布隆过滤器的 API 类（BloomFilter.class），它是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建存储整型的布隆过滤器</span></span><br><span class="line">bloomFilter =</span><br><span class="line">        BloomFilter.create(Funnels.integerFunnel(), expectedInsertions, fpp);</span><br></pre></td></tr></table></figure>

<h4 id="讲一下缓存雪崩问题"><a href="#讲一下缓存雪崩问题" class="headerlink" title="讲一下缓存雪崩问题"></a>讲一下缓存雪崩问题</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>缓存数据在同一时间大面积失效或者缓存服务器宕机，导致大量请求直接到达数据库，造成数据库宕机</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>设置随机过期时间，避免大量的key同时过期</li>
<li>进行缓存预热，在部署之前将可能问的数据预先访问一遍  避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩</li>
<li>部署redis集群，个别节点宕机，依然可以保持服务的整体可用。</li>
</ol>
<h4 id="讲一下缓存击穿"><a href="#讲一下缓存击穿" class="headerlink" title="讲一下缓存击穿"></a>讲一下缓存击穿</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>一份热点数据，在缓存失效瞬间，大量请求访问</p>
<p>一份冷门数据，突然被大量请求访问，但缓存中并没有该数据</p>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>加互斥锁<ul>
<li>对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存取值。</li>
</ul>
</li>
<li>不设置过期时间</li>
</ol>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><h4 id="TCP-IP各层结构与功能，以及常见协议"><a href="#TCP-IP各层结构与功能，以及常见协议" class="headerlink" title="TCP&#x2F;IP各层结构与功能，以及常见协议"></a>TCP&#x2F;IP各层结构与功能，以及常见协议</h4><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p><strong>功能：为特定应用提供数据传输服务</strong></p>
<ul>
<li>它定义了信息交换的格式，消息会交给下一层传输层来传输。</li>
<li>应用层工作在操作系统的用户态，传输层及以下工作在内核态</li>
</ul>
<p><strong>应用层常见协议：</strong></p>
<ul>
<li>HTTP:超文本传输协议</li>
<li>SMTP:简单邮件传输协议， 基于 TCP 协议，用来发送电子邮件</li>
<li>POP3&#x2F;IMAP：邮件接收协议</li>
<li>FTP：文件传输协议，基于TCP实现。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</li>
<li>SSH：安全的网络传输协议  可以有效防止远程管理过程中的信息泄露问题</li>
<li>DNS：域名解析， 将域名网址自动转换为具体的IP地址</li>
</ul>
<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/application-layer-protocol.png" alt="应用层常见协议" style="zoom:80%;" />

<ul>
<li>Telnet: 远程登陆协议 所有数据（包括用户名和密码）均以明文形式发送，有安全风险</li>
</ul>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p><strong>作用：为进程提供通用数据传输服务</strong></p>
<p>传输层作为应用间数据传输的媒介，实现应用到应用的通信，并不负责将数据从一个设备传到另一个设备。</p>
<p><strong>传输层常见协议：</strong></p>
<ul>
<li>TCP传输控制协议</li>
<li>UDP用户数据报协议</li>
</ul>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p><strong>作用：为网络中的主机提供数据传输服务，主要是路由和转发</strong></p>
<p>传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成<strong>分组</strong>。</p>
<p><strong>常见协议：</strong></p>
<ul>
<li>IP</li>
<li>ICMP</li>
</ul>
<img src="https://cdn.nlark.com/yuque/0/2022/png/12395513/1647849158167-ea140a92-e16e-49f6-ae6b-5cb7a21165d9.png" alt="image.png" style="zoom:67%;" />

<h5 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h5><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p>
<ol>
<li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li>
<li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li>
</ol>
<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP&#x2F;UDP"></a>TCP&#x2F;UDP</h3><h4 id="TCP的三次握手和四次挥手的内容？TCP为什么连接是三次握手断开是四次挥手？"><a href="#TCP的三次握手和四次挥手的内容？TCP为什么连接是三次握手断开是四次挥手？" class="headerlink" title="TCP的三次握手和四次挥手的内容？TCP为什么连接是三次握手断开是四次挥手？"></a>TCP的三次握手和四次挥手的内容？TCP为什么连接是三次握手断开是四次挥手？</h4><h5 id="什么是TCP？"><a href="#什么是TCP？" class="headerlink" title="什么是TCP？"></a>什么是TCP？</h5><p>TCP是<strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>基于字节流的</strong>传输层协议。</p>
<ul>
<li><strong>面向连接：</strong>一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的：</strong>TCP用了多种机制去保证数据的可靠传输；</li>
<li><strong>字节流：</strong>TCP传输数据时以字节为单位，当应用消息通过TCP协议传输时，消息被视为一个字节流装入到TCP报文段中。</li>
</ul>
<h5 id="什么是TCP连接？"><a href="#什么是TCP连接？" class="headerlink" title="什么是TCP连接？"></a>什么是TCP连接？</h5><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小</strong></p>
<p>建立一个TCP连接需要客户端与服务器端达成下面三个共识：</p>
<ul>
<li>Socket：由IP地址和端口号组成</li>
<li>序列号：用来解决乱序问题等</li>
<li>窗口大小：用来做流量控制</li>
</ul>
<h5 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h5><img src="https://cdn.nlark.com/yuque/0/2022/png/12395513/1657955609001-38ed499f-14f0-4c3c-ae11-5f5aa529c75a.png?x-oss-process=image%2Fresize%2Cw_732%2Climit_0" alt="image.png" style="zoom:80%;" />



<p>首先服务端应处于监听状态，等待客户端的连接请求。</p>
<ul>
<li>第一次握手：客户端向服务端发送连接请求报文，SYN标志位&#x3D;1，并选择一个随机的初始序列号x</li>
<li>第二次握手：服务端收到客户端的连接请求，如果同意建立连接，则向客户端发送连接确认报文，SYN标志位&#x3D;1，ACK标志位&#x3D;1，确认号为x+1，也会选择一个随机的初始化序列号y</li>
<li>第三次握手：客户端接收到服务端的连接确认报文后，还要向服务端发出确认，ACK标志位&#x3D;1，确认号为y+1，序列号为x+1</li>
</ul>
<p>PS:第三次握手可以携带数据，前两次不能携带</p>
<h5 id="为什么要三次握手？不是两次、四次？"><a href="#为什么要三次握手？不是两次、四次？" class="headerlink" title="为什么要三次握手？不是两次、四次？"></a>为什么要三次握手？不是两次、四次？</h5><p>首先，三次握手的目的是建立可靠的通信信道，双方确认自己与对方的发送与接收都是正常的。</p>
<ul>
<li>第一次握手：Server确认了：对方发送正常，自己接收正常</li>
<li>第二次握手：Client确认了：自己发送正常、接受正常，对方发送、接受正常</li>
<li>第三次握手：Server确认了：自己发送、接收正常，对方发送、接收正常</li>
</ul>
<p>其次，需要三次握手的原因为：</p>
<ul>
<li>第三次握手<strong>是为了防止失效的历史连接请求到达服务器，让服务器错误打开连接。</strong></li>
<li>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么<strong>服务器就会打开两个连接。</strong></li>
<li>如果有第三次握手，<strong>客户端会忽略服务器之后发送的对滞留连接请求的连接确认</strong>，不进行第三次握手，因此就不会再次打开连接</li>
</ul>
<p><strong>为什么不是四次握手：</strong>三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</p>
<h5 id="四次挥手的过程"><a href="#四次挥手的过程" class="headerlink" title="四次挥手的过程"></a>四次挥手的过程</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12395513/1649213788873-bc420706-7ab0-440b-a723-a2f24d2bdd89.png?x-oss-process=image/resize,w_673,limit_0" alt="image.png"></p>
<p><img src="/image-20240319222922475.png" alt="image-20240319222922475"></p>
<h5 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h5><p>客户端发送了FIN连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<h4 id="TCP与UDP的区别和使用场景？"><a href="#TCP与UDP的区别和使用场景？" class="headerlink" title="TCP与UDP的区别和使用场景？"></a>TCP与UDP的区别和使用场景？</h4><p>区别：</p>
<ol>
<li><strong>是否面向连接：</strong>UDP在传输数据前不需要先建立连接，而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输：</strong>TCP提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，保证通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>传输效率：</strong>由于使用TCP进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式：</strong>TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销：</strong>TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务：</strong>TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多。</li>
</ol>
<p>什么时候选择TCP，什么时候选择UDP：</p>
<ul>
<li><strong>UDP一般用于即时通信，</strong>比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP用于对传输准确性要求特别高的场景，</strong>比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h4 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h4><p>主要有<strong>检验和</strong>、<strong>序列号</strong>、<strong>重传</strong>、<strong>流量控制</strong>、<strong>拥塞控制</strong>等方式。</p>
<ol>
<li><strong>序列号和确认应答保证数据包的有序性和不重复。</strong>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>重传机制：</strong>在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：基于计时器的重传（也就是超时重传）、快速重传（基于接收端的反馈信息来引发重传）、SACK（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）、D-SACK（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）。</li>
<li><strong>流量控制：</strong>TCP利用滑动窗口实现流量控制，窗口大小指的是<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。窗口可以理解为一个固定大小的缓冲区，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</li>
<li><strong>拥塞控制：</strong>当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</li>
</ol>
<p>​	TCP实现拥塞控制主要由慢开始、拥塞避免、快重传、快恢复：</p>
<img src="image-20240319232345459.png" alt="image-20240319232345459" style="zoom:80%;" />

<p>快重传和快恢复主要是为了改进TCP的性能，有时候个别TCP报文段再网络中丢失，但网络并未发生阻塞，这会导致发送方超时重传，并且误以为网络发生阻塞从而执行慢开始算法，把拥塞窗口设置为1，降低了传输速率。</p>
<p>快重传就是使发送方快速重传丢失的报文段，这需要接收方在收到乱序的报文段后对已收到的报文段进行重复确认，发送方一旦收到三个连续的重复确认，就会立即对丢失的报文段进行重传。</p>
<p>快恢复算法配合快重传算法使用，发送方收到三个重复确认就知道当前只是丢失了个别报文段，于是不执行慢开始算法转而执行快恢复算法，将拥塞窗口和慢开始门限都调整为当前拥塞窗口的一般，再执行拥塞避免算法。</p>
<h4 id="TCP粘包问题？"><a href="#TCP粘包问题？" class="headerlink" title="TCP粘包问题？"></a>TCP粘包问题？</h4><h5 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h5><p>由于TCP是面向字节流的传输协议，没有定义明确的边界，因此可能出现在一条消息中读到了另一条消息的部分数据的现象，该现象被称为粘包。</p>
<h5 id="粘包的解决方法"><a href="#粘包的解决方法" class="headerlink" title="粘包的解决方法"></a>粘包的解决方法</h5><ol>
<li>发送方和接收方固定发送数据的大小，这个方法不太灵活</li>
<li>发送数据时在头部定义发送数据大小的信息，这样接收方解析数据头可以得知数据的具体长度，不会出现粘包的问题</li>
<li>以特殊字符结尾，这样可以知道数据的边界，从而避免粘包问题</li>
</ol>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP报文格式？"><a href="#HTTP报文格式？" class="headerlink" title="HTTP报文格式？"></a>HTTP报文格式？</h4><h5 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h5><ol>
<li>请求行：请求方法(get&#x2F;post…)+URL+协议版本</li>
<li>请求头：一些键值对形式的附加信息，主要通知服务器有关于客户端请求的信息。</li>
<li>请求体：请求的实体数据</li>
</ol>
<h5 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h5><ol>
<li>响应行：协议版本号   +   状态码   +   状态码说明</li>
<li>响应头：一些键值对表示响应信息</li>
<li>响应体：服务端返回给客户端的数据</li>
</ol>
<h4 id="HTTP状态码有哪些？"><a href="#HTTP状态码有哪些？" class="headerlink" title="HTTP状态码有哪些？"></a>HTTP状态码有哪些？</h4><p>HTTP状态码用于描述HTTP请求的结果：</p>
<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png" alt="常见 HTTP 状态码" style="zoom:80%;" />

<h4 id="从输入URL到页面展示发生了什么"><a href="#从输入URL到页面展示发生了什么" class="headerlink" title="从输入URL到页面展示发生了什么"></a>从输入URL到页面展示发生了什么</h4><p>总体上分为以下几个步骤：</p>
<ol>
<li>在浏览器中输入指定网页的URL</li>
<li>浏览器通过DNS协议，获取域名对应的IP地址</li>
<li>浏览器通过IP地址和端口号，向目标服务器建立一个TCP连接，发起HTTP请求</li>
<li>服务器收到HTTP请求报文，处理请求，并返回HTTP响应报文给浏览器</li>
<li>浏览器收到HTTP响应报文后，解析响应体中的HTML代码，渲染网页，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li>
<li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li>
</ol>
<h4 id="URL和URI有什么区别？"><a href="#URL和URI有什么区别？" class="headerlink" title="URL和URI有什么区别？"></a>URL和URI有什么区别？</h4><p>简单来说，URL是一个地址，它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。URI是统一资源标志符，可以唯一标识一个资源。</p>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h4 id="DNS有什么用？解析过程？"><a href="#DNS有什么用？解析过程？" class="headerlink" title="DNS有什么用？解析过程？"></a>DNS有什么用？解析过程？</h4><p>DNS是域名管理系统，解决了域名与IP地址的映射问题。</p>
<p>解析过程：</p>
<ol>
<li>首先查找浏览器缓存、本地Host文件中是否存在对应缓存</li>
<li>没查找到会向本地的DNS解析器发送DNS查询请求</li>
<li>如果本地DNS解析器没有对应记录，会向根DNS服务器发出查询请求，根DNS服务器并不负责具体解析域名，而是告诉本地DNS解析器去哪个顶级域DNS服务器继续查</li>
<li>顶级域DNS服务器也不负责具体的域名解析，而是告诉本地DNS解析器前往哪一个权威DNS服务器查询</li>
<li>最后向权威DNS服务器发出查询请求，从权威DNS服务器中得到IP地址</li>
<li>本地DNS解析器将IP地址返回给浏览器，并将解析结果缓存到本地</li>
</ol>
<h4 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h4><ol>
<li>HTTP的信息明文传输，存在安全风险。HTTPS解决了HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL安全协议，使报文能够加密传输</li>
<li>HTTPS在TCP三次握手之后，还需要进行SSL&#x2F;TLS握手过程，才可以进行加密报文传输</li>
<li>HTTPS协议需要向CA申请数字证书来保证服务器的身份可信</li>
<li>HTTP的默认端口号是80，HTTPS的默认端口号是443</li>
</ol>
<h4 id="HTTPS的连接过程？"><a href="#HTTPS的连接过程？" class="headerlink" title="HTTPS的连接过程？"></a>HTTPS的连接过程？</h4><ol>
<li><strong>认证：</strong><ul>
<li>客户端将支持的加密算法信息发给服务器</li>
<li>服务器选择一套客户端支持的加密算法，以证书的形式回发给客户端</li>
<li>客户端解析证书，检验证书的合法性</li>
</ul>
</li>
<li><strong>协商会话密钥：</strong><ul>
<li>认证合法后，客户端生成对称加密的会话密钥，用服务器的公钥对<strong>会话密钥</strong>进行非对称加密。</li>
<li>将加密之后的会话密钥发送给服务器</li>
<li>服务器接收到客户端发来的密文后，用服务器的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用<strong>客户端密钥</strong>对数据进行对称加密，这样数据就变成了密文。</li>
</ul>
</li>
<li><strong>传输：</strong><ul>
<li>服务器将加密后的密文发送给客户端，表示握手阶段已经结束，随后的信息都将用「会话秘钥」加密通信。</li>
</ul>
</li>
</ol>
<p><img src="/image-20240315121258406.png" alt="image-20240315121258406"></p>
<h4 id="HTTP1-0、1-1、2-0的区别？"><a href="#HTTP1-0、1-1、2-0的区别？" class="headerlink" title="HTTP1.0、1.1、2.0的区别？"></a>HTTP1.0、1.1、2.0的区别？</h4><h5 id="1-1与1-0的区别："><a href="#1-1与1-0的区别：" class="headerlink" title="1.1与1.0的区别："></a>1.1与1.0的区别：</h5><ul>
<li>HTTP1.1支持长连接和请求的流水线操作，Http1.0使用短连接，每次请求都要重新建立一次连接，资源消耗大，长连接减少了TCP连接的重复建立和断开所造成的额外开销。 请求的流水线操作是指在收到HTTP响应报文之前可以先发送新的请求报文。</li>
<li>HTTP1.1增加了Host域来标识一个ip地址下对应的多个域名</li>
</ul>
<h5 id="1-1和2-0的区别："><a href="#1-1和2-0的区别：" class="headerlink" title="1.1和2.0的区别："></a>1.1和2.0的区别：</h5><ul>
<li>二进制分帧：HTTP 1.x在应用层以<strong>纯文本的形式进行通信</strong>，而<strong>HTTP 2.0将所有的传输信息分割为更小的消息和帧</strong>，并对它们采用<strong>二进制格式编码</strong>。</li>
<li>多路复用：在一个TCP连接上同时发送多个请求和响应来解决HTTP1.1中队头阻塞的问题。这意味着多个HTTP请求可以并行发送和接收，而无需等待之前的请求完成。每个请求和响应都被分配一个唯一的标识符，称为流（Stream），通过这个标识符可以将相应的数据包装在一起，并在另一端进行解析和重新组装。</li>
<li>首部压缩：HTTP2.0对首部进行了压缩，同时在客户端和服务端之间使用“<strong>首部表</strong>”来跟踪和存储之前发送的键-值对，不需要每次通信都需要再携带首部。</li>
</ul>
<h4 id="Cookie和Session了解吗？"><a href="#Cookie和Session了解吗？" class="headerlink" title="Cookie和Session了解吗？"></a>Cookie和Session了解吗？</h4><p>Cookie是存储在客户端的小型文本文件，用于保持用户的会话状态。</p>
<p>Session存储在服务器上，用于跟踪用户状态和存储用户信息。</p>
<h4 id="Cookie、Session、Token的区别？"><a href="#Cookie、Session、Token的区别？" class="headerlink" title="Cookie、Session、Token的区别？"></a>Cookie、Session、Token的区别？</h4><p>Cookie是由服务器发送到用户浏览器并存储在客户端的小段数据。它通常用于识别用户并保持会话状态。</p>
<p>Session是在服务器端创建并维护的用户会话信息。与Cookie不同，Session数据存储在服务器端，并通过唯一的会话标识符（通常存储在Cookie中）与用户关联。</p>
<p>Token是一种身份验证和授权机制，与Cookie和Session不同，Token是无状态的，意味着服务器不需要维护用户会话信息。相反，客户端在每次请求时附带Token，服务器验证其有效性并授权访问资源。Token的主要优势在于其可扩展性和跨域能力，适用于分布式系统和跨多个应用程序的身份验证。</p>
<h4 id="Get和Post的区别？"><a href="#Get和Post的区别？" class="headerlink" title="Get和Post的区别？"></a>Get和Post的区别？</h4><ol>
<li><strong>作用不同</strong><ul>
<li>Get用于获取资源</li>
<li>POST用于传输实体主体</li>
</ul>
</li>
<li><strong>参数存放位置不同</strong><ul>
<li>Get参数以查询字符串出现在URL中</li>
<li>POST参数存储在报文的body中</li>
</ul>
</li>
<li><strong>幂等性</strong><ul>
<li>Get请求是幂等的</li>
<li>POST请求不是幂等的</li>
</ul>
</li>
</ol>
<h3 id="IP层"><a href="#IP层" class="headerlink" title="IP层"></a>IP层</h3><h4 id="PING有什么作用？工作原理是什么？"><a href="#PING有什么作用？工作原理是什么？" class="headerlink" title="PING有什么作用？工作原理是什么？"></a>PING有什么作用？工作原理是什么？</h4><p>PING用来测试两台主机之间的连通性和网络延迟。</p>
<p>PING命令主要利用ICMP(网际控制报文协议)实现，其原理为：通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h4 id="网络号和主机号有什么用？"><a href="#网络号和主机号有什么用？" class="headerlink" title="网络号和主机号有什么用？"></a>网络号和主机号有什么用？</h4><p>IP地址是以网络号和主机号来标示网络上的主机的，我们把网络号相同的主机称之为本地网络，网络号不相同的主机称之为远程网络主机，本地网络中的主机可以直接相互通信；远程网络中的主机要相互通信必须通过本地网关（Gateway）来传递转发数据。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>进程：程序的一次执行过程，是系统分配资源的最小单位。系统系统运行一个程序就是一个进程从创建、运行到消亡的过程</p>
<p>线程：是比进程更小的执行单位  一个进程在执行过程中可以产生多个线程；</p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ol>
<li><strong>拥有资源：</strong>进程是分配资源的基本单位，而线程隶属于进程，可以访问进程中的共享资源，只独享必不可少的资源如寄存器和栈</li>
<li><strong>系统开销：</strong>创建或撤销进程系统都要为之分配或回收资源，如内存空间、I&#x2F;O 设备等，所付出的开销远大于创建或撤销线程时的开销。进程进行上下文切换的开销也远高于线程。</li>
<li><strong>通信：</strong>线程间可以通过读写同一进程的数据进行通信，但是进程通信需要借助 IPC。</li>
<li><strong>安全性：</strong>进程之间资源隔离，而线程之间存在共享资源，因此多线程并发的安全问题比较严重。</li>
</ol>
<h4 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12395513/1658584505300-82768973-9c2c-4943-b791-6df5a128d907.png" alt="image.png"></p>
<h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><ol>
<li>管道</li>
<li>消息队列</li>
<li>信号量</li>
<li>信号</li>
<li>共享内存</li>
<li>Socket</li>
</ol>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="常见的内存管理方式？"><a href="#常见的内存管理方式？" class="headerlink" title="常见的内存管理方式？"></a>常见的内存管理方式？</h4><ul>
<li><strong>段式管理：</strong>以段(—段连续的物理内存)的形式管理&#x2F;分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息</li>
<li><strong>页式管理：</strong>把物理内存分为连续等长的物理页，应用程序的虚拟地址空间也被划分为连续等长的虚拟页，是现代操作系统广泛使用的一种内存管理方式。</li>
<li><strong>段页式管理：</strong>结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。</li>
</ul>
<h4 id="分页管理的地址映射方式？"><a href="#分页管理的地址映射方式？" class="headerlink" title="分页管理的地址映射方式？"></a>分页管理的地址映射方式？</h4><p>分页管理通过 <strong>页表（Page Table）</strong> 映射虚拟地址和物理地址。</p>
<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/page-table.png" alt="单级页表" style="zoom:67%;" />

<p>在分页机制下，每个应用程序都会有一个对应的页表。</p>
<p>分页机制下的虚拟地址由两部分组成：</p>
<ul>
<li><strong>页号</strong>：通过虚拟页号可以从页表中取出对应的物理页号；</li>
<li><strong>页内偏移量</strong>：物理页起始地址+页内偏移量&#x3D;物理内存地址。</li>
</ul>
<p>具体的地址翻译过程如下：</p>
<ol>
<li>MMU 首先解析得到虚拟地址中的虚拟页号；</li>
<li>通过虚拟页号去该应用程序的页表中取出对应的物理页号（找到对应的页表项）；</li>
<li>用该物理页号对应的物理页起始地址（物理地址）加上虚拟地址中的页内偏移量得到最终的物理地址。</li>
</ol>
<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/paging-virtual-address-composition.png" alt="分页机制下的地址翻译过程" style="zoom: 80%;" />

<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件系统中的索引节点和目录项"><a href="#文件系统中的索引节点和目录项" class="headerlink" title="文件系统中的索引节点和目录项"></a>文件系统中的索引节点和目录项</h4><p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（*index node*）和目录项（*directory entry*）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p>
<ul>
<li>索引节点，也就是 <em>inode</em>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<strong>数据在磁盘的位置</strong>等等。索引节点是文件的<strong>唯一</strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。</li>
<li>目录项，也就是 <em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</li>
</ul>
<p>目录项可以理解为inode和文件名的键值对，由于索引节点唯一标识一个文件，而目录项记录着文件的名字，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别名。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</p>
<h4 id="软链接和硬链接的区别"><a href="#软链接和硬链接的区别" class="headerlink" title="软链接和硬链接的区别"></a>软链接和硬链接的区别</h4><p>硬链接是<strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。由于多个目录项都是指向一个 inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E9%93%BE%E6%8E%A5-2.png" alt="硬链接" style="zoom: 67%;" />

<p>软链接相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E9%93%BE%E6%8E%A5.png" alt="软链接" style="zoom:67%;" />

<p>硬链接只能在同一文件系统中创建，因为它们与原始文件共享inode。软链接可以跨越不同的文件系统，因为它们是指向目标文件的路径。这是由于硬链接和软链接的不同实现方式和对文件系统的依赖性所致。</p>
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="谈一谈Spring-IOC"><a href="#谈一谈Spring-IOC" class="headerlink" title="谈一谈Spring IOC"></a>谈一谈Spring IOC</h4><p>IOC(控制反转)是一种设计思想，指的是将原本在程序中手动创建对象的控制权交给Spring框架来管理。</p>
<img src="https://oss.javaguide.cn/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png" alt="IoC 图解" style="zoom:80%;" />

<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。当我们需要使用IoC容器中的对象时，一般采用依赖注入的形式。</p>
<p>Spring IOC的实现依赖于IOC容器，下面是Spring IOC的工作流程：</p>
<p>IOC工作流程：</p>
<ol>
<li>初始化IOC容器：根据程序中声明的bean通过解析和加载后生成BeanDefination，然后把BeanDefination注册到IOC容器中。</li>
<li>完成单例Bean的创建，保存到IOC容器中。</li>
</ol>
<h4 id="什么是Spring-Bean？如何声明一个Bean？"><a href="#什么是Spring-Bean？如何声明一个Bean？" class="headerlink" title="什么是Spring Bean？如何声明一个Bean？"></a>什么是Spring Bean？如何声明一个Bean？</h4><p>Bean就是那些被IOC容器管理的对象</p>
<p>Spring中可以通过XML的方式去声明一个Bean</p>
<p>不过在Spring Boot中使用的更多的方式是用注解去声明一个Bean。</p>
<p>跟声明Bean有关的注解有：</p>
<p><strong>@Component：</strong>作用于类上，表示将类作为一个Bean，通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中。</p>
<p><strong>@Bean：</strong>作用于方法上，表示该方法返回了一个Bean加入到IOC容器中，一般是使用第三方库中的类时要用@Bean。</p>
<h4 id="简单描述下Spring-Bean的生命周期？"><a href="#简单描述下Spring-Bean的生命周期？" class="headerlink" title="简单描述下Spring Bean的生命周期？"></a>简单描述下Spring Bean的生命周期？</h4><p>Bean的生命周期概括起来分为四个阶段：</p>
<ol>
<li>实例化：第1步，实例化一个bean对象</li>
<li>属性赋值：第2步，为bean设置相关属性和依赖</li>
<li>初始化：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用；</li>
<li>销毁：第 8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 bean 时再执行相应的方法。</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/1704860a4de235aa~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>这里初始化为什么这么复杂呢？其实是Spring为bean的使用提供了许多扩展点，下面介绍一下这些扩展点。</p>
<h5 id="Aware接口"><a href="#Aware接口" class="headerlink" title="Aware接口"></a>Aware接口</h5><p>若 Spring 检测到 bean 实现了 Aware 接口，则会为其注入相应的依赖。所以<strong>通过让bean 实现 Aware 接口，则能在 bean 中获得相应的 Spring 容器资源</strong>。</p>
<p>Spring 中提供的 Aware 接口有：</p>
<ol>
<li>BeanNameAware：注入当前 bean 对应 beanName；</li>
<li>BeanClassLoaderAware：注入加载当前 bean 的 ClassLoader；</li>
<li>BeanFactoryAware：注入 当前BeanFactory容器 的引用。</li>
</ol>
<h5 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h5><p>BeanPostProcessor 是 Spring 为<strong>修改 bean</strong>提供的强大扩展点，其可作用于容器中所有 bean，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化前置处理</span></span><br><span class="line">	<span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化后置处理</span></span><br><span class="line">	<span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用场景有：为当前对象提供代理实现。例如 Spring AOP 功能，生成对象的代理类，然后返回。</p>
<h5 id="InitializingBean-和-init-method"><a href="#InitializingBean-和-init-method" class="headerlink" title="InitializingBean 和 init-method"></a>InitializingBean 和 init-method</h5><p>InitializingBean 和 init-method 是 Spring 为 <strong>bean 初始化</strong>提供的扩展点。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>最后总结下如何记忆 Spring Bean 的生命周期：</p>
<ul>
<li>首先是实例化、属性赋值、初始化、销毁这 4 个大阶段；</li>
<li>再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作；</li>
<li>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</li>
</ul>
<h4 id="Spring如何解决循环依赖？"><a href="#Spring如何解决循环依赖？" class="headerlink" title="Spring如何解决循环依赖？"></a>Spring如何解决循环依赖？</h4><p>总结一下：<strong>Spring中使用三次缓存设计，解决了单例模式下setter注入的循环依赖问题</strong>。</p>
<h5 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h5><p>Spring 中单例 Bean 在创建后会被放入 IOC 容器中，然后触发 Spring 对 Bean 的生命周期管理。</p>
<p>保存单例 Bean 的缓存池，采用了三级缓存设计，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/TLH3CicPVibrc82aq55YicGXslH31WPb6PaUmHKnOawJ3fPcP4jeylwbtlpRGAVeU4H0ug359LAAbzADbz6HMIAfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一级缓存</span></span><br><span class="line"><span class="comment"> * 保存beanName和创建bean实例之间的关系，存放已经实例化、属性赋值、完成初始化好的Bean</span></span><br><span class="line"><span class="comment"> * Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三级缓存</span></span><br><span class="line"><span class="comment"> * 保存beanName和创建bean的工厂之间的关系</span></span><br><span class="line"><span class="comment"> * Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二级缓存</span></span><br><span class="line"><span class="comment"> * 存放原始bean对象（还未填充属性）</span></span><br><span class="line"><span class="comment"> * 与singletonObjects不同之处在于: 当一个单例bean被放到这里之后, 那么当bean还在创建过程中就可以通过getBean方法获取到, 可以方便检查循环依赖</span></span><br><span class="line"><span class="comment"> * Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bean 创建过程都会在里面待着</span></span><br><span class="line"><span class="comment"> * Bean 开始创建时放值，创建完成后移除</span></span><br><span class="line"><span class="comment"> * Names of beans that are currently in creation. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">		Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bean 被创建完后会放到这里</span></span><br><span class="line"><span class="comment"> * Names of beans that have already been created at least once. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>))</span><br></pre></td></tr></table></figure>

<p>一级缓存用于缓存已经创建好的单例bean实例；二级缓存用于缓存正在创建中的bean实例，还未进行属性注入；三级缓存用于缓存bean工厂对象，用于解决循环依赖。</p>
<p>总结下如何使用三级缓存解决单例 Bean 的循环依赖：</p>
<ol>
<li>创建对象 A，完成生命周期的第一步，即<strong>实例化</strong>，在调用 <code>createBeanInstance</code> 方法后，会调用 <code>addSingletonFactory</code> 方法，将已实例化但未属性赋值、未初始化的对象 A 放入三级缓存 <code>singletonFactories</code> 中。即将对象 A 提早曝光给 IoC 容器。</li>
<li>继续，执行对象 A 生命周期的第二步，即<strong>属性赋值</strong>。此时，发现对象 A 依赖对象，所以就会尝试去获取对象 B。</li>
<li>继续，发现 B 尚未创建，所以会执行创建对象 B 的过程。</li>
<li>在创建对象 B 的过程中，执行实例化和属性赋值操作。此时发现，对象 B 依赖对象 A。</li>
<li>继续，尝试在缓存中查找对象 A。先查找一级缓存，发现一级缓存中没有对象 A（因为对象 A 还未初始化完成）；转而查找二级缓存，二级缓存中也没有对象 A（因为对象 A 还未属性赋值）；转而查找三级缓存 <code>singletonFactories</code>，对象 B 可以通过 <code>ObjectFactory.getObject</code> 拿到对象 A。</li>
<li>继续，对象 B 在获取到对象 A 后，继续执行属性赋值和初始化操作。<strong>对象 B 完成初始化操作后，会被存放到一级缓存中，而对象 A 会被放到二级缓存中</strong>。</li>
<li>继续，转到「对象 A <strong>执行属性赋值过程</strong>并发现依赖了对象 B」的场景。此时，<strong>对象 A 可以从一级缓存中获取到对象 B</strong>，所以可以顺利执行属性赋值操作。</li>
<li>继续，对象 A 执行初始化操作，完成后，会被存放到<strong>一级缓存</strong>中。</li>
</ol>
<h5 id="为什么是三级缓存？"><a href="#为什么是三级缓存？" class="headerlink" title="为什么是三级缓存？"></a>为什么是三级缓存？</h5><p><strong>如果 Spring 选择二级缓存来解决循环依赖的话，那么就意味着所有 Bean 都需要在实例化完成之后就立马为其创建代理，而 Spring 的设计原则是在 Bean 初始化完成之后才为其创建代理。</strong>(意思就是如果只有两个缓存，A在B完成了初始化之后就会被放到一级缓存，但此时A还没有完成初始化，也就是没有生成代理对象，最终放到一级缓存里的应该是代理对象，所以中间加一个二级缓存)</p>
<blockquote>
<p>使用三级缓存而非二级缓存并不是因为只有三级缓存才能解决循环引用问题，其实二级缓存同样也能很好解决循环引用问题。使用三级而非二级缓存并非出于 IOC 的考虑，而是出于 AOP 的考虑，即若使用二级缓存，在 AOP 情形注入到其他 Bean的，不是最终的代理对象，而是原始对象。</p>
</blockquote>
<h4 id="说一说对AOP的理解"><a href="#说一说对AOP的理解" class="headerlink" title="说一说对AOP的理解"></a>说一说对AOP的理解</h4><p>AOP(面向切面编程)也是一种编程思想，是将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，然后将其织入到方法中实现方法增强。便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess"></p>
<img src="https://img-blog.csdnimg.cn/20201207001947787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

<h4 id="Spring-MVC的核心组件有哪些？工作原理了解吗？"><a href="#Spring-MVC的核心组件有哪些？工作原理了解吗？" class="headerlink" title="Spring MVC的核心组件有哪些？工作原理了解吗？"></a>Spring MVC的核心组件有哪些？工作原理了解吗？</h4><p>Spring MVC的核心组件如下：</p>
<ul>
<li><code>DispatcherServlet:</code><strong>核心的中央处理器</strong>，负责接受请求、分发，并给予客户端响应。</li>
<li><code>HandlerMapping:</code><strong>处理器映射器</strong>，根据URL去匹配查找能处理的Handler，并且会将请求涉及到的拦截器和Handler一起封装。</li>
<li><code>HandlerAdapter:</code> <strong>处理器适配器</strong>，根据HandlerMapping找到的Handler，适配执行对应的Handler</li>
<li><code>Handler：</code> <strong>请求处理器</strong>，处理实际请求的处理器</li>
<li><code>ViewResolver:</code> <strong>视图解析器</strong>，根据<code>Handler</code>返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li>
</ul>
<p>SpringMVC的工作原理：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/de6d2b213f112297298f3e223bf08f28.png" alt="img"></p>
<ol>
<li>客户端发送请求，<code>DispatcherServlet</code>拦截请求</li>
<li><code>DispatcherServlet</code>根据请求信息调用 <code>HandlerMapping</code>。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code></li>
<li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h4 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h4><p>Spring支持两种事务管理方式：编程式事务管理和声明式事务管理，一般用的多的是声明式事务管理。</p>
<h5 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h5><p>声明式事务的原理基于Spring AOP，其本质是对方法前后进行拦截，在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
<img src="https://img-blog.csdnimg.cn/e2dbe61112c34462afd48f75911c057c.png" alt="在这里插入图片描述" style="zoom: 80%;" />

<h5 id="Transactional失效场景"><a href="#Transactional失效场景" class="headerlink" title="@Transactional失效场景"></a>@Transactional失效场景</h5><ol>
<li>@Transactional注解作用在非public方法上导致注解失效</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/dd0361f8f3934de3a43c62a0d1c46904.png" alt="在这里插入图片描述"></p>
<ol start="2">
<li>事务传播级别设置错误导致注解失效</li>
<li>数据库不支持事务导致注解失效</li>
<li>同一个类方法之间相互调用导致注解失效，PS：为什么这里是原始类呢？因为代理类需要从IOC容器中获取，得采用@Autowired或者@Resource注入的方式，这种this调用是原始类调用的。</li>
</ol>
<img src="https://img-blog.csdnimg.cn/0e88e51f95d045f5875badbc2c91dd36.png" alt="img" style="zoom:67%;" />

<ol start="5">
<li>异常被catch导致事务失效</li>
</ol>
<h4 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h4><p>SpringBoot自动装配就是自动将第三方包中的bean加载到IOC容器中，不需要自己再去做配置，体现了约定大于配置的理念</p>
<p>开启自动装配需要引入@SpringBootAplication，该注解是复合注解，真正实现自动装配的注解是@EnableAutoConfiguration。它的实现原理是通过SpringFactoriesLoader加载META-INF&#x2F;spring.factories获取到第三方包中的配置类，再通过ImportSelector实现配置类的动态加载，实现自动装配。</p>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="什么是SQL注入，如何防止SQL注入？"><a href="#什么是SQL注入，如何防止SQL注入？" class="headerlink" title="什么是SQL注入，如何防止SQL注入？"></a>什么是SQL注入，如何防止SQL注入？</h4><p>SQL注入是指攻击者在应用程序中输入恶意SQL代码执行SQL查询或者更改命令，这可能导致数据库被攻击者非法访问、数据泄露、数据篡改或系统瘫痪等问题。</p>
<p>MyBatis为了防止SQL注入可以使用#代替$，因为#采用的是预编译方式将用户输入数据作为参数传递，$的是动态拼接的方式，有可能导致SQL注入。</p>
<h3 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h3><h4 id="Cookie-和-Session-有什么区别？如何使⽤-Session-进⾏身份验证？"><a href="#Cookie-和-Session-有什么区别？如何使⽤-Session-进⾏身份验证？" class="headerlink" title="Cookie 和 Session 有什么区别？如何使⽤ Session 进⾏身份验证？"></a>Cookie 和 Session 有什么区别？如何使⽤ Session 进⾏身份验证？</h4><p>Cookie存储在客户端，一般用于保持用户会话状态，比如使用 <code>Cookie</code> 保存 <code>SessionId</code> 或者 <code>Token</code> ，向后端发送请求的时候带上 <code>Cookie</code>，这样后端就能取到 <code>Session</code> 或者 <code>Token</code> 了。</p>
<p>Session存储在服务端，一般用于记录用户的状态信息。</p>
<p>使用Session进行身份验证需要用户发起请求时携带SessionID，根据SessionID获取到Session进行身份验证。</p>
<h4 id="Token和Session有什么区别？"><a href="#Token和Session有什么区别？" class="headerlink" title="Token和Session有什么区别？"></a>Token和Session有什么区别？</h4><p>Token和Session都是实现身份验证的方式，二者的校验流程不同：</p>
<p>Session进行身份验证依赖于Cookie，客户端向服务端发送请求需要通过Cookie携带SessionID，服务端提取cookie中的SessionID和后端保存的信息进行对比。</p>
<p>Token是服务端对用户id等信息进行加密生成的令牌，客户端发起的请求需要携带Token，服务端收到后对token进行验证，通过检查Token的合法性来进行身份验证。</p>
<p>所以核心区别就是session需要将登录信息存储在服务器上，token一般不需要存储在服务器上，而是通过一些算法去解析token实现认证。</p>
<p>token和session其实是时间与空间的博弈问题，session是空间换时间，而token是时间换空间。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="单例模式了解么？"><a href="#单例模式了解么？" class="headerlink" title="单例模式了解么？"></a>单例模式了解么？</h4><p>单例模式是指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p>
<p>单例模式下的类构造方法是私有的，类自身定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p>
<h5 id="如何实现一个单例模式，讲讲spring中的单例模式"><a href="#如何实现一个单例模式，讲讲spring中的单例模式" class="headerlink" title="如何实现一个单例模式，讲讲spring中的单例模式"></a>如何实现一个单例模式，讲讲spring中的单例模式</h5><p>1.懒汉式double Check</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键点：</p>
<ul>
<li>double check：可能会有多个线程阻塞在synchronized处，第一个获得锁的线程返回后instance就已经被实例化了，所以后续的线程再次获得锁进入同步代码块后需要先检查一下</li>
<li>volatile保持线程间的可见性和防止指令重排</li>
</ul>
<p>2.饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ststic <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>静态内部类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleTon</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类也是懒加载的，因为类是懒加载的，在第一次被使用的时候才会被加载到JVM中。</p>
<p>4.枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line">	Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要利用了枚举的如下两个特性：</p>
<ul>
<li>枚举的构造器总是私有的，所以不必像前几种方式一样显式定义私有构造方法</li>
<li>枚举类中的每个值，都是实例（只有<code>INSTANCE</code>这一个实例）</li>
</ul>
<p>Spring中的bean默认就是单例的</p>
<h5 id="单例模式线程安全吗？"><a href="#单例模式线程安全吗？" class="headerlink" title="单例模式线程安全吗？"></a>单例模式线程安全吗？</h5><p>单例模式线程不安全，因为所有线程会共享一个Bean实例</p>
<h5 id="怎么保证一个单例的线程安全？"><a href="#怎么保证一个单例的线程安全？" class="headerlink" title="怎么保证一个单例的线程安全？"></a>怎么保证一个单例的线程安全？</h5><p>1.使用无状态的bean，不在bean中定义成员变量</p>
<p>2.使用ThreadLocal线程本地变量</p>
<h4 id="观察者模式了解吗？说一下观察者模式的使用场景"><a href="#观察者模式了解吗？说一下观察者模式的使用场景" class="headerlink" title="观察者模式了解吗？说一下观察者模式的使用场景"></a>观察者模式了解吗？说一下观察者模式的使用场景</h4><p>观察者模式是一种行为型设计模式，它建立了一种对象之间的一对多依赖关系，使得当一个对象的状态发生变化时，其相关依赖对象都能够接收到通知并自动更新。</p>
<p>场景：当很多对象同时对某一个主题感兴趣时，可以采用观察者模式实现发布-订阅模式。<strong>例如，生产者发送消息到消息队列中，并通知所有订阅此队列的消费者进行消费。</strong></p>
<h4 id="⼯⼚模式了解么？说⼀下⼯⼚模式的使⽤场景。"><a href="#⼯⼚模式了解么？说⼀下⼯⼚模式的使⽤场景。" class="headerlink" title="⼯⼚模式了解么？说⼀下⼯⼚模式的使⽤场景。"></a>⼯⼚模式了解么？说⼀下⼯⼚模式的使⽤场景。</h4><p>工厂模式是一种创建型设计模式，它提供了一种封装对象实例化过程的方式，以便于在需要时动态创建对象，而无需直接使用构造函数。客户端在创建对象时无需关心具体的创建过程，只需要传入参数即可。</p>
<p>工厂模式最大的优点就是将对象的创建和使用解耦，减少代码的耦合性。</p>
<h4 id="装饰器模式？"><a href="#装饰器模式？" class="headerlink" title="装饰器模式？"></a>装饰器模式？</h4><p>装饰器模式（Decorator Pattern） 也称为包装模式(Wrapper Pattern) 是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案(扩展原有对象的功能)，属于结构型模式。装饰器模式的核心是功能扩展，使用装饰器模式可以透明且动态地扩展类的功能。</p>
<p><img src="https://img-blog.csdnimg.cn/4f4e8e4591874d36bda9e2567f04fdca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5om25oiR6LW35p2l77yB5oiR6L-Y6IO956CB77yB,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>抽象组件（Component）： 可以是一个接口或者抽象类，其充当被装饰类的原始对象，规定了被装饰对象的行为；</p>
</li>
<li><p>具体组件（ConcreteComponent）： 实现&#x2F;继承Component的一个具体对象，也即被装饰对象；</p>
</li>
<li><p>抽象装饰器（Decorator）： 通用的装饰ConcreteComponent的装饰器，其内部必然有一个属性指向Component抽象组件；其实现一般是一个抽象类，主要是为了让其子类按照其构造形式传入一个Component抽象组件，这是强制的通用行为（当然，如果系统中逻辑单一，并不需要实现许多装饰器，那么我们可以直接省略该类，而直接实现一个具体装饰器（ComcreteDecorator）即可）；</p>
</li>
<li><p>具体装饰器（ConcreteDecorator）： Decorator的具体实现类，理论上，每个ConcreteDecorator都扩展了Component对象的一种功能；</p>
</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h4 id="为什么要用消息队列？"><a href="#为什么要用消息队列？" class="headerlink" title="为什么要用消息队列？"></a>为什么要用消息队列？</h4><ol>
<li><strong>通过异步处理提高系统性能</strong></li>
<li><strong>削峰&#x2F;限流</strong></li>
<li><strong>降低系统耦合性</strong></li>
</ol>
<h5 id="异步处理提高系统性能"><a href="#异步处理提高系统性能" class="headerlink" title="异步处理提高系统性能"></a>异步处理提高系统性能</h5><img src="https://oss.javaguide.cn/github/javaguide/Asynchronous-message-queue.png" alt="通过异步处理提高系统性能" style="zoom: 80%;" />

<p>对于一个比较耗时的操作，先将其写到消息队列中，然后返回处理结果，最后系统再对消息进行消费。</p>
<p>比如在网上云盘系统中，用户删除文件操作就采用了消息队列的方式异步处理，提高了接口的性能。用户在回收站中删除文件不仅需要操作数据库，而且需要在文件物理存储引擎上进行彻底删除，调用文件物理存储引擎删除文件比较耗时，因此可以将其拆分成两步操作，首先删除数据库中用户文件关联信息，然后将物理删除文件的操作写到消息队列中，然后直接返回，最后由系统对物理删除文件消息进行消费实现物理删除，这样异步操作提高了接口的处理速度。</p>
<h5 id="削峰-限流"><a href="#削峰-限流" class="headerlink" title="削峰&#x2F;限流"></a>削峰&#x2F;限流</h5><p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，避免同一时间的大量请求使后端服务崩溃。</strong></p>
<img src="https://oss.javaguide.cn/github/javaguide/%E5%89%8A%E5%B3%B0-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="削峰" style="zoom: 67%;" />

<h5 id="降低系统耦合性"><a href="#降低系统耦合性" class="headerlink" title="降低系统耦合性"></a>降低系统耦合性</h5><p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，系统的可扩展性更好。</p>
<h4 id="Rocket-MQ概述"><a href="#Rocket-MQ概述" class="headerlink" title="Rocket MQ概述"></a>Rocket MQ概述</h4><p><img src="https://developer.qcloudimg.com/http-save/yehe-2596032/c0761a21e3aad1659bc4cb8489263518.png" alt="img"></p>
<p>Rocket MQ整体架构中包含四种角色：</p>
<ol>
<li><strong>NameServer：</strong>Topic的路由注册中心，其角色类似 Dubbo 中的 zookeeper ，支持 Broker 的动态注册与发现。</li>
<li><strong>BrokerServer：</strong>Broker 主要负责消息的存储、投递和查询以及服务高可用保证 。</li>
<li><strong>Producer：</strong>消息发布的角色，Producer 通过 MQ 的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡</a>模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</li>
<li><strong>Consumer：</strong>消息消费的角色，支持以 push 推，pull 拉两种模式对消息进行消费。</li>
</ol>
<p>Rocket MQ工作流程：</p>
<p>1、<strong>启动 NameServer</strong>，NameServer 起来后监听端口，等待 Broker、Producer 、Consumer 连上来，相当于一个路由控制中心。</p>
<p>2、<strong>Broker 启动</strong>，跟所有的 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker信息( IP+端口等 )以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</p>
<p>3、收发消息前，先<strong>创建 Topic</strong>，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic。</p>
<p>4、<strong>Producer 发送消息</strong>，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker 发消息。</p>
<p>5、Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始<strong>消费消息</strong>。</p>
<h4 id="Rocket-MQ的消息消费失败怎么办？"><a href="#Rocket-MQ的消息消费失败怎么办？" class="headerlink" title="Rocket MQ的消息消费失败怎么办？"></a>Rocket MQ的消息消费失败怎么办？</h4><p>若Consumer消费某条消息失败，则<strong>RocketMQ会在重试间隔时间后，将消息重新投递给Consumer消费，若达到最大重试次数后消息还没有成功被消费，则消息将被投递至死信队列。</strong>死信队列的消息将不会再被消费。应该通知人工介入处理。</p>
<ul>
<li>在集群模式下，消费的业务逻辑代码会返回 Action.ReconsumerLater，NULL，或者抛出异常，如果一条消息消费失败，最多会重试 16 次，之后该消息会被丢弃。</li>
<li>在广播消费模式下，广播消费仍然保证消息至少被消费一次，但不提供重发的选项。</li>
</ul>
<h4 id="Rocket-MQ如何保证消息不丢失？"><a href="#Rocket-MQ如何保证消息不丢失？" class="headerlink" title="Rocket MQ如何保证消息不丢失？"></a>Rocket MQ如何保证消息不丢失？</h4><p>消息的整体处理阶段可以分为三个阶段：</p>
<ol>
<li>Producer发送消息阶段</li>
<li>Broker处理消息阶段</li>
<li>Consumer消费消息阶段</li>
</ol>
<h5 id="发送消息怎么保证不丢失？"><a href="#发送消息怎么保证不丢失？" class="headerlink" title="发送消息怎么保证不丢失？"></a>发送消息怎么保证不丢失？</h5><p>主要通过同步发送+重试机制+多master减少消息丢失的可能性</p>
<h5 id="Broker处理消息怎么保证不丢失？"><a href="#Broker处理消息怎么保证不丢失？" class="headerlink" title="Broker处理消息怎么保证不丢失？"></a>Broker处理消息怎么保证不丢失？</h5><p>在Broker阶段可以采用同步刷盘的机制来持久化消息，解决消息丢失的问题</p>
<h5 id="Consumer消费阶段？"><a href="#Consumer消费阶段？" class="headerlink" title="Consumer消费阶段？"></a>Consumer消费阶段？</h5><p>Rocket MQ默认提供了At least Once机制来保证消息的可靠消费，主要是Consumer在消费消息之后需要向Broker返回消费结果，如果没有返回消费结果会将消息重新投递给消费者。</p>
<h4 id="如何保证消息不被重复消费？"><a href="#如何保证消息不被重复消费？" class="headerlink" title="如何保证消息不被重复消费？"></a>如何保证消息不被重复消费？</h4><p>消息队列本身不会保证消息不被重复消费，消息不丢失与消息不重复二者是冲突的，因此需要消费者自己去实现消息不被重复消费。</p>
<p>可以通过在消费者端实现幂等性消费来避免重复消费的影响。</p>
<p><strong>幂等性：任意多次执行所产生的影响均与一次执行的影响相同。</strong></p>
<p>幂等性需要结合具体业务实现，下面是两种常用方法：</p>
<ol>
<li>利用redis实现，在消息消费成功之后将MessageId设置到redis中，在消费之前用 set if not exist命令判断该消息是否已经被消费过</li>
<li>在数据表中设置唯一key来保证重复数据不会被插入多条</li>
</ol>
<h4 id="如何保证顺序消费？"><a href="#如何保证顺序消费？" class="headerlink" title="如何保证顺序消费？"></a>如何保证顺序消费？</h4><p>顺序消费分为两点：<strong>生产者有序发送</strong>和<strong>消费者有序消费</strong>。</p>
<h5 id="生产者有序发送"><a href="#生产者有序发送" class="headerlink" title="生产者有序发送"></a>生产者有序发送</h5><p>我们知道RocketMQ中生产者生产的消息会放置在某个队列中，基于队列先进先出的特性天然的可以保证存入队列的消息顺序和拉取的消息顺序是一致的，因此，我们只需要保证一组相同的消息按照给定的顺序存入同一个队列中，就能保证生产者有序存储。</p>
<p>在是同RocketMQ实现顺序消息发送时可以实现MessageQueueSelector 接口去选择消息要发送到的队列。</p>
<p><img src="https://img-blog.csdnimg.cn/direct/07357cf763054314af4629d202209fcf.png" alt="img"></p>
<h5 id="消费者有序消费"><a href="#消费者有序消费" class="headerlink" title="消费者有序消费"></a>消费者有序消费</h5><p>RocketMQ 消费过程包括两种，分别是并发消费和有序消费。</p>
<ul>
<li><p>并发消费</p>
<p>并发消费的接口 MessageListenerConcurrently</p>
<p>并发消费是 RocketMQ 默认的处理方法，</p>
<p>并发消费 场景，消费者使用线程池技术，可以并发消费多条消息，提升机器的资源利用率。</p>
<p>默认配置是 20 个线程，所以一台机器默认情况下，同一瞬间可以消费 20 个消息。</p>
</li>
<li><p>有序消费 MessageListenerOrderly</p>
<p>有序消费模式 的接口是，MessageListenerOrderly。</p>
<p>在消费的时候，还需要保证消费者注册MessageListenerOrderly类型的回调接口，去实现顺序消费，如果消费者采用Concurrently并行消费，则仍然不能保证消息消费顺序。</p>
<p>MessageListenerOrderly 有序消息监听器</p>
</li>
</ul>
<p>在消费的时候，还需要保证消费者注册MessageListenerOrderly类型的回调接口，去实现顺序消费。</p>
<p><img src="https://img-blog.csdnimg.cn/direct/cfa72f38430641bea46719e89e1c327e.png" alt="img"></p>
<p>顺序消费的事件监听器为 MessageListenerOrderly，表示顺序消费。</p>
<ul>
<li>并发消费消息时，当消费失败时，会默认延迟重试16次。</li>
<li>有序消费消息时，重试次数为 Integer.MAX_VALUE，而且不延迟。</li>
</ul>
<p>换言之，有序消费场景，如果某一条消息消费失败且重试始终失败，将会导致后续的消息无法消费，产生消息的积压。</p>
<p>所以，顺序消费消息时，一定要谨慎处理异常情况。防止消息队列积压。</p>
<h4 id="Kafka与Rocket-MQ区别？"><a href="#Kafka与Rocket-MQ区别？" class="headerlink" title="Kafka与Rocket MQ区别？"></a>Kafka与Rocket MQ区别？</h4><p>Kafka适用于海量数据场景，对数据的正确性要求不是特别严格</p>
<p>Rocket MQ适合业务处理，具有数据可靠性、数据实时性等特点</p>
<h4 id="Spring-Cloud-Stream？"><a href="#Spring-Cloud-Stream？" class="headerlink" title="Spring Cloud Stream？"></a>Spring Cloud Stream？</h4><p>Spring Cloud Stream是一个消息驱动框架，它屏蔽了消息中间件的具体使用细节，用Binder来连接Spring应用和消息中间件，定义Channel来描述消息在应用程序中的输入输出通道。生产者将消息发送到输出通道，消费者从输入通道接收消息。这样，开发者只需要关注消息的生产和消费逻辑，而不需要关心消息在具体的消息代理中是如何传输。</p>
<img src="https://img-blog.csdnimg.cn/db03a51ee7cd44c3bcb3e35b47e78b20.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjEwMTgzOQ==,size_16,color_FFFFFF,t_60" alt="img" style="zoom:50%;" />

<h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><h4 id="秒杀场景怎么设计？如何提高并发量？"><a href="#秒杀场景怎么设计？如何提高并发量？" class="headerlink" title="秒杀场景怎么设计？如何提高并发量？"></a>秒杀场景怎么设计？如何提高并发量？</h4><ol>
<li>异步扣库存，将库存扣减操作设置为异步执行，通过消息队列等方式进行处理</li>
<li>设置缓存预减库存，使用分布式缓存（如Redis）存储商品库存信息，并通过缓存快速判断库存是否充足。在秒杀等活动中，可以将商品的库存信息预加载到缓存中，并在请求到达时先从缓存中读取库存信息进行判断，减少对数据库的访问次数。当请求到达时，先在内存中进行库存检查和扣减操作。如果库存不足，则快速返回失败结果，避免对数据库的频繁访问。之后，再将扣减后的库存更新到数据库中，保持数据一致性。</li>
<li>分库分表：将商品库存信息进行分库分表存储，使库存的读写操作能够在多个数据库实例上并行处理。通过水平拆分数据库和数据表，可以提高并发处理能力，分摊扣减库存的压力。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5f64aaed183d54d9b9885c891674840f.png" alt="Image"></p>
<h4 id="读接口并发量高怎么优化？"><a href="#读接口并发量高怎么优化？" class="headerlink" title="读接口并发量高怎么优化？"></a>读接口并发量高怎么优化？</h4><p>当读接口并发量高时，可以采用<strong>限流</strong>、<strong>缓存</strong>和<strong>数据库查询优化</strong>等方式。</p>
<h5 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h5><p>限流是控制接口请求速率的一种手段，目的是防止因过多的请求而导致的系统崩溃或资源耗尽。</p>
<ul>
<li><strong>令牌桶算法或漏桶算法</strong>：使用这两种算法来限制接口的请求速率。令牌桶算法允许突发流量，而漏桶算法则更加平滑。</li>
<li><strong>分布式限流</strong>：对于微服务架构，可以使用Redis等分布式系统来实现全局限流。</li>
<li><strong>API网关限流</strong>：在API网关层进行限流，可以保护后端服务不受过量请求的冲击。</li>
</ul>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>缓存可以显著提高接口的响应速度，减少对数据库的访问次数。</p>
<ol>
<li><strong>本地缓存</strong>：使用如Guava Cache、Ehcache等本地缓存库，存储热点数据。</li>
<li><strong>分布式缓存</strong>：对于需要共享缓存的场景，可以使用Redis、Memcached等分布式缓存系统。</li>
</ol>
<h5 id="数据库查询优化"><a href="#数据库查询优化" class="headerlink" title="数据库查询优化"></a>数据库查询优化</h5><p>数据库查询优化是提升接口性能的关键环节。</p>
<ol>
<li><strong>索引优化</strong>：确保经常查询的字段都有合适的索引，同时避免全表扫描。</li>
<li><strong>SQL语句优化</strong>：简化复杂的SQL语句，避免在SQL中使用子查询和复杂的连接操作。</li>
<li><strong>读写分离读写</strong>：使用主从复制等技术，将读操作和写操作分离到不同的数据库服务器上，提高并发性能。</li>
<li><strong>批量操作</strong>：尽量减少数据库的操作次数，可以将多次操作合并为一次批量操作。</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h3><h4 id="linux常考命令"><a href="#linux常考命令" class="headerlink" title="linux常考命令"></a>linux常考命令</h4><h5 id="Cat命令：查看文件内容"><a href="#Cat命令：查看文件内容" class="headerlink" title="Cat命令：查看文件内容"></a>Cat命令：查看文件内容</h5><p>用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用：</p>
<ul>
<li>cat file1 从第一个字节开始正向查看文件的内容</li>
<li>tac file1 从最后一行开始反向查看一个文件的内容</li>
<li>cat -n file1 标示文件的行数</li>
<li>more file1 查看一个长文件的内容</li>
<li>head -n 2 file1 查看一个文件的前两行</li>
<li>tail -n 2 file1 查看一个文件的最后两行</li>
<li>tail -n +1000 file1 从1000行开始显示，显示1000行以后的</li>
<li>cat filename | head -n 3000 | tail -n +1000 显示1000行到3000行</li>
<li>cat filename | tail -n +3000 | head -n 1000 从第3000行开始，显示1000(即显示3000~3999行)</li>
</ul>
<p>重要命令：tail -f test.log 实时查看log日志中的信息</p>
<h5 id="find命令：搜索文件"><a href="#find命令：搜索文件" class="headerlink" title="find命令：搜索文件"></a>find命令：搜索文件</h5><ul>
<li>find &#x2F; -name file1 从 ‘&#x2F;‘ 开始进入根文件系统搜索文件和目录</li>
<li>find &#x2F; -user user1 搜索属于用户 ‘user1’ 的文件和目录</li>
<li>find &#x2F;usr&#x2F;bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件</li>
<li>find &#x2F;usr&#x2F;bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件</li>
<li>whereis halt 显示一个二进制文件、源码或man的位置</li>
<li>which halt 显示一个二进制文件或可执行文件的完整路径</li>
</ul>
<h5 id="grep命令：文本处理"><a href="#grep命令：文本处理" class="headerlink" title="grep命令：文本处理"></a>grep命令：文本处理</h5><p>分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等：</p>
<ul>
<li>grep Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找关键词”Aug”</li>
<li>grep ^Aug &#x2F;var&#x2F;log&#x2F;messages 在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找以”Aug”开始的词汇</li>
<li>grep [0-9] &#x2F;var&#x2F;log&#x2F;messages 选择 ‘&#x2F;var&#x2F;log&#x2F;messages’ 文件中所有包含数字的行</li>
<li>grep Aug -R &#x2F;var&#x2F;log&#x2F;* 在目录 ‘&#x2F;var&#x2F;log’ 及随后的目录中搜索字符串”Aug”</li>
</ul>
<h5 id="jps命令"><a href="#jps命令" class="headerlink" title="jps命令"></a>jps命令</h5><p>显示当前系统的java进程情况，及其id号</p>
<h5 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h5><p>查看进程，用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p>
<h5 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h5><p>用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，默认是终止进程。</p>
<h5 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h5><p>是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p>
<h5 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h5><img src="image-20240316205936166.png" alt="image-20240316205936166" style="zoom:50%;" />

<h5 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h5><p>打包命令：</p>
<ul>
<li>tar -cf test  打包test文件</li>
<li>tar -xf test.tar 解包test文件</li>
<li>tar -zxvf test  压缩test文件</li>
<li>tar -zcvf test.tar.gz 解压test文件</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/" rel="tag"># 常见面试问题及答案</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2024/02/16/LRU%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/" rel="next" title="LRU缓存实现">
      LRU缓存实现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%8A%E8%81%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.1.</span> <span class="nav-text">聊聊面向对象的三大特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">抽象类和接口的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84%E2%BC%8F%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%90%84%E2%BE%83%E5%8D%A0%E2%BD%A4%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E5%91%A2%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">Java 中的⼏种基本数据类型是什么？对应的包装类型是什么？各⾃占⽤多少字节呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-%E3%80%81-StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-number">1.1.4.</span> <span class="nav-text">String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-s1-new-String-%E2%80%9Cabc%E2%80%9D-%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%88%9B%E5%BB%BA%E4%BA%86%E2%BC%8F%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">String s1 &#x3D; new String(“abc”); 这段代码创建了⼏个字符串对象？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8Eequals%EF%BC%9FhashCode%E4%B8%8Eequals%EF%BC%9F"><span class="nav-number">1.1.6.</span> <span class="nav-text">&#x3D;&#x3D;与equals？hashCode与equals？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">1.1.7.</span> <span class="nav-text">包装类型的缓存机制了解吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="nav-number">1.1.8.</span> <span class="nav-text">深拷贝和浅拷贝了解吗？什么是引用拷贝？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exception%E5%92%8CErr%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.9.</span> <span class="nav-text">Exception和Err有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99serialVersionUID%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.1.10.</span> <span class="nav-text">Java的序列化和反序列化是什么？序列化的时候serialVersionUID有什么用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E5%8F%8D%E5%B0%84%EF%BC%9F%E5%8F%8D%E5%B0%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%8F%8D%E5%B0%84%E7%9A%84%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E5%8F%8D%E5%B0%84%EF%BC%89%EF%BC%9F"><span class="nav-number">1.1.11.</span> <span class="nav-text">Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E6%B3%9B%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F"><span class="nav-number">1.1.12.</span> <span class="nav-text">Java 泛型了解么？什么是类型擦除？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BIO%EF%BC%8CNIO%EF%BC%8CAIO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.13.</span> <span class="nav-text">BIO，NIO，AIO有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK8%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.14.</span> <span class="nav-text">JDK8中的新特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88"><span class="nav-number">1.2.</span> <span class="nav-text">Java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-List-Set-Map-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%89%E8%80%85%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">说说 List,Set,Map 三者的区别？三者底层的数据结构？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList%E5%92%8CArrayList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">LinkedList和ArrayList的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">集合的线程安全问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fail-fast%E5%92%8Cfail-safe%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">Fail-fast和fail-safe？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Fail-fast%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Fail-fast：快速失败</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fail-safe%EF%BC%9A%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">fail-safe：安全失败</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E8%A7%A3%E6%9E%90"><span class="nav-number">1.2.5.</span> <span class="nav-text">HashMap解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">HashMap底层实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">HashMap容量大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">HashMap的线程安全问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap%E8%A7%A3%E6%9E%90"><span class="nav-number">1.2.6.</span> <span class="nav-text">ConcurrentHashMap解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrentHashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">ConcurrentHashMap底层实现方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">ConcurrentHashMap实现线程安全的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrenHashMap%E7%9A%84get%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E6%9C%89%E5%81%9A%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E5%90%97%EF%BC%9F"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">ConcurrenHashMap的get方法里面有做并发处理吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="nav-number">1.3.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么是线程和进程?线程与进程的关系,区别及优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9F%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">死锁产生的条件？如何预防和避免死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F"><span class="nav-number">1.3.3.</span> <span class="nav-text">乐观锁和悲观锁了解么？如何实现乐观锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">1.3.4.</span> <span class="nav-text">CAS的实际应用：原子类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-sleep-%E2%BD%85%E6%B3%95%E5%92%8C-wait-%E2%BD%85%E6%B3%95%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">1.3.5.</span> <span class="nav-text">说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B2%E2%BC%80%E4%B8%8B-JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E3%80%82-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.3.6.</span> <span class="nav-text">讲⼀下 JMM(Java 内存模型)。 volatile 关键字解决了什么问题？说说 synchronized 关键字和 volatile 关键字的区别。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C-JMM-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.7.</span> <span class="nav-text">Java 内存区域和 JMM 有何区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#happens-before-%E5%8E%9F%E5%88%99"><span class="nav-number">1.3.8.</span> <span class="nav-text">happens before 原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E2%BD%A4"><span class="nav-number">1.3.9.</span> <span class="nav-text">synchronized 关键字的作⽤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E5%92%8CreentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.10.</span> <span class="nav-text">synchronized和reentrantLock的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.11.</span> <span class="nav-text">synchronized关键字的底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E2%BD%A4%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.12.</span> <span class="nav-text">ThreadLocal 关键字的作⽤，内存泄露问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E2%BD%A4%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E2%BD%A4%E5%86%85%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.3.13.</span> <span class="nav-text">线程池有什么⽤？为什么不推荐使⽤内置线程池？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%9F%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E2%BC%8F%E7%A7%8D%EF%BC%9F%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E2%BC%8F%E7%A7%8D%EF%BC%9F"><span class="nav-number">1.3.14.</span> <span class="nav-text">Java 线程池有哪些参数？阻塞队列有⼏种？拒绝策略有⼏种？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9A"><span class="nav-number">1.3.14.1.</span> <span class="nav-text">阻塞队列：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.14.2.</span> <span class="nav-text">线程池的拒绝策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">1.3.15.</span> <span class="nav-text">线程池处理任务的流程了解吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E5%92%8CCallable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.16.</span> <span class="nav-text">实现Runnable接口和Callable接口的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Submit-%E5%92%8Cexecute-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.17.</span> <span class="nav-text">Submit()和execute()方法有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FAQS%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">1.3.18.</span> <span class="nav-text">AQS是什么？AQS的三大组件？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CountDownLatch%E5%92%8CCyclicBarrier%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.18.1.</span> <span class="nav-text">CountDownLatch和CyclicBarrier的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM"><span class="nav-number">1.4.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%85%B1%E4%BA%AB%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0OOM%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0OOM%EF%BC%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">Java运行时数据区包含哪些？哪些线程共享哪些不共享？哪些区域可能出现OOM？哪些区域不会出现OOM？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">方法区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%9C%A8%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE%EF%BC%88JDK1-7-%E4%B9%8B%E5%89%8D%E5%9C%A8%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%8CJDK1-7-%E5%9C%A8%E5%A0%86%EF%BC%89%EF%BC%9FJDK-1-7-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%A0%86%E4%B8%AD%EF%BC%9F"><span class="nav-number">1.4.2.</span> <span class="nav-text">字符串常量池在什么位置（JDK1.7 之前在永久代，JDK1.7 在堆）？JDK 1.7 为什么要将字符串常量池移动到堆中？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%AF%B9%E8%B1%A1%E4%BC%9A%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="nav-number">1.4.3.</span> <span class="nav-text">堆空间的基本结构了解吗？什么情况下对象会进入老年代？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.4.4.</span> <span class="nav-text">直接内存有什么用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E2%AD%90%E2%AD%90"><span class="nav-number">1.4.5.</span> <span class="nav-text">Java对象的创建过程⭐⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Step1%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">Step1：类加载检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Step2%EF%BC%9A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">Step2：分配内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Step3%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">Step3：初始化零值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Step4%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">1.4.5.4.</span> <span class="nav-text">Step4：设置对象头</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Step5%EF%BC%9A%E6%89%A7%E8%A1%8Cinit%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.5.5.</span> <span class="nav-text">Step5：执行init方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Minor-GC%E3%80%81%E8%BF%98%E6%9C%89-Full-GC-%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82Minor-GC-%E4%B8%8E-Full-GC-%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E2%BD%A3%EF%BC%9F-Minor-GC-%E4%BC%9A%E5%8F%91%E2%BD%A3-stop-the-world-%E7%8E%B0%E8%B1%A1%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.6.</span> <span class="nav-text">谈谈你对 Minor GC、还有 Full GC 的理解。Minor GC 与 Full GC 分别在什么时候发⽣？ Minor GC 会发⽣ stop the world 现象吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Full-GC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">1.4.7.</span> <span class="nav-text">Full GC的触发机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1%EF%BC%88%E5%BC%95%E2%BD%A4%E8%AE%A1%E6%95%B0%E6%B3%95%E5%92%8C%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E4%B8%A4%E7%A7%8D%E2%BD%85%E6%B3%95%EF%BC%89%EF%BC%9F"><span class="nav-number">1.4.8.</span> <span class="nav-text">如何判断对象是否死亡（引⽤计数法和可达性分析算法两种⽅法）？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">1. 引用计数法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">2.可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.9.</span> <span class="nav-text">四种引用类型知道吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%EF%BC%8C%E5%90%84%E2%BE%83%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">1.4.10.</span> <span class="nav-text">垃圾收集有哪些算法，各⾃的特点？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.10.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.10.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.10.3.</span> <span class="nav-text">标记-整理算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.4.11.</span> <span class="nav-text">垃圾收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BCMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.4.12.</span> <span class="nav-text">讲一下CMS收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BG1%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.4.13.</span> <span class="nav-text">讲一下G1收集器？有什么缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%9F%E4%BD%95%E6%97%B6%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.4.14.</span> <span class="nav-text">什么是类加载？何时进行类加载？类加载流程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.4.15.</span> <span class="nav-text">知道哪些类加载器？类加载器之间的关系？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9FTomcat%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">1.4.16.</span> <span class="nav-text">类加载器的双亲委派了解么？Tomcat如何打破双亲委派机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">1.4.17.</span> <span class="nav-text">双亲委派模型的好处？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Tomcat%E8%A6%81%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%9F"><span class="nav-number">1.4.17.1.</span> <span class="nav-text">为什么Tomcat要破坏双亲委派？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="nav-number">1.4.18.</span> <span class="nav-text">JVM常见指令和工具</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JPS"><span class="nav-number">1.4.18.1.</span> <span class="nav-text">JPS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Jconsole"><span class="nav-number">1.4.18.2.</span> <span class="nav-text">Jconsole</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jstat"><span class="nav-number">1.4.18.3.</span> <span class="nav-text">jstat</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Jstack"><span class="nav-number">1.4.18.4.</span> <span class="nav-text">Jstack</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jmap"><span class="nav-number">1.4.18.5.</span> <span class="nav-text">jmap</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5OOM%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-number">1.4.19.</span> <span class="nav-text">怎么排查OOM的情况？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL"><span class="nav-number">2.1.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.</span> <span class="nav-text">InnoDB和MyISAM的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8MYSQL%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="nav-number">2.1.2.</span> <span class="nav-text">说一说一条查询语句在MYSQL中的执行流程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.1.3.</span> <span class="nav-text">char 和 varchar 的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">2.1.4.</span> <span class="nav-text">索引的优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E2%BE%AE%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%BE%AE%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E2%BC%80%E5%AE%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97"><span class="nav-number">2.1.5.</span> <span class="nav-text">聚集索引和⾮聚集索引的区别？⾮聚集索引⼀定回表查询吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E2%BC%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E2%BC%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F"><span class="nav-number">2.1.6.</span> <span class="nav-text">索引这么多优点，为什么不对表中的每⼀个列创建⼀个索引呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">2.1.7.</span> <span class="nav-text">最左前缀匹配原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">2.1.8.</span> <span class="nav-text">索引失效的场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%8F%AF%E4%BB%A5%E7%A9%BA%E5%90%97%EF%BC%9F%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%8F%AF%E4%BB%A5%E7%A9%BA%E5%90%97%EF%BC%9F"><span class="nav-number">2.1.9.</span> <span class="nav-text">唯一索引和主键索引区别？唯一索引可以空吗？主键索引可以空吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.10.</span> <span class="nav-text">事务的四大特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F-%E5%AF%B9%E5%BA%94ACID%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.11.</span> <span class="nav-text">事务的实现原理？(对应ACID特性)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">2.1.11.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">2.1.11.2.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-number">2.1.11.3.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">2.1.11.4.</span> <span class="nav-text">持久性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.12.</span> <span class="nav-text">并发事务一致性的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%84%8F%E8%AF%BB"><span class="nav-number">2.1.12.1.</span> <span class="nav-text">脏读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">2.1.12.2.</span> <span class="nav-text">不可重复读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%BB%E8%AF%BB"><span class="nav-number">2.1.12.3.</span> <span class="nav-text">幻读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.12.4.</span> <span class="nav-text">不可重复读和幻读的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">2.1.13.</span> <span class="nav-text">事务隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%9C%AA%E6%8F%90%E4%BA%A4"><span class="nav-number">2.1.13.1.</span> <span class="nav-text">读取未提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-number">2.1.13.2.</span> <span class="nav-text">读取已提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">2.1.13.3.</span> <span class="nav-text">可重复读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-number">2.1.13.4.</span> <span class="nav-text">可串行化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97"><span class="nav-number">2.1.14.</span> <span class="nav-text">MySQL 的隔离级别是基于锁实现的吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.15.</span> <span class="nav-text">MVCC的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="nav-number">2.1.16.</span> <span class="nav-text">RR隔离级别下怎么解决幻读？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E7%9A%84binlog%E4%B8%BB%E8%A6%81%E8%AE%B0%E5%BD%95%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.17.</span> <span class="nav-text">MySQL的binlog主要记录什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redo-log%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">2.1.18.</span> <span class="nav-text">redo log如何保证事务的持久性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bin-log%E5%92%8Credo-log%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.19.</span> <span class="nav-text">bin log和redo log有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undo-log%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">2.1.20.</span> <span class="nav-text">undo log有什么用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E5%9C%A8MYSQL%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.21.</span> <span class="nav-text">一条更新语句在MYSQL中的执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90SQL%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">2.1.22.</span> <span class="nav-text">如何分析SQL的性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84SQL%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="nav-number">2.1.23.</span> <span class="nav-text">有哪些常见的SQL优化手段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8select"><span class="nav-number">2.1.23.1.</span> <span class="nav-text">1.避免使用select *</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5"><span class="nav-number">2.1.23.2.</span> <span class="nav-text">2.优化深度分页</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BC%98%E5%8C%96%E6%85%A2SQL"><span class="nav-number">2.1.23.3.</span> <span class="nav-text">3.优化慢SQL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.23.4.</span> <span class="nav-text">4.正确使用索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%81%94%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%8F%E8%A1%A8%E5%9C%A8%E5%89%8D"><span class="nav-number">2.1.23.5.</span> <span class="nav-text">5.联表的时候小表在前</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E8%81%94%E8%A1%A8%E4%B8%8D%E8%A6%81%E5%A4%AA%E5%A4%9A"><span class="nav-number">2.1.23.6.</span> <span class="nav-text">6.联表不要太多</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9F"><span class="nav-number">2.1.24.</span> <span class="nav-text">读写分离？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.1.24.1.</span> <span class="nav-text">主从复制的原理是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F"><span class="nav-number">2.1.24.2.</span> <span class="nav-text">主从复制带来的问题：主从延迟</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="nav-number">2.1.25.</span> <span class="nav-text">分库分表？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%BA%93%EF%BC%9F"><span class="nav-number">2.1.25.1.</span> <span class="nav-text">什么是分库？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="nav-number">2.1.25.2.</span> <span class="nav-text">什么是分表？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis"><span class="nav-number">2.2.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="nav-number">2.2.1.</span> <span class="nav-text">Redis为什么这么快？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">2.2.2.</span> <span class="nav-text">Redis是单线程的吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E5%BF%AB%EF%BC%9F"><span class="nav-number">2.2.3.</span> <span class="nav-text">为什么Redis采用单线程？单线程为什么还快？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.2.4.</span> <span class="nav-text">Redis常见数据结构及使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#String"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#List"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hash"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Set"><span class="nav-number">2.2.4.4.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#zset"><span class="nav-number">2.2.4.5.</span> <span class="nav-text">zset</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Redis%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">2.2.5.</span> <span class="nav-text">为什么用Redis而不是本地内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7Key%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">2.2.6.</span> <span class="nav-text">大Key问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%A7key%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">大key有什么问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E5%A4%A7key%EF%BC%9F"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">如何查找大key？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E5%A4%A7key%EF%BC%9F"><span class="nav-number">2.2.6.3.</span> <span class="nav-text">如何删除大key？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%A7key%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">2.2.6.4.</span> <span class="nav-text">如何解决大key问题？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%83%ADKey%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.7.</span> <span class="nav-text">热Key问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.7.1.</span> <span class="nav-text">问题定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">2.2.7.2.</span> <span class="nav-text">如何解决？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BAOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.2.8.</span> <span class="nav-text">说一下AOF持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BRDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.2.9.</span> <span class="nav-text">说一下RDB持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E4%B8%80%E4%B8%8BRDB%E5%92%8CAOF%EF%BC%9F"><span class="nav-number">2.2.10.</span> <span class="nav-text">比较一下RDB和AOF？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="nav-number">2.2.11.</span> <span class="nav-text">缓存读写策略？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Cache-Aside-Pattern-%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98"><span class="nav-number">2.2.11.1.</span> <span class="nav-text">Cache Aside Pattern(旁路缓存)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.12.</span> <span class="nav-text">缓存与数据库的一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%90%8E%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98-%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="nav-number">2.2.12.1.</span> <span class="nav-text">先更新数据库，后更新缓存(不推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%90%8E%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="nav-number">2.2.12.2.</span> <span class="nav-text">先删除缓存，后更新数据库(不推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%90%8E%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98-%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.12.3.</span> <span class="nav-text">先更新数据库，后删除缓存(推荐使用)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%BB%B6%E8%BF%9F%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.12.4.</span> <span class="nav-text">主从库延迟和延迟双删问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.13.</span> <span class="nav-text">讲一下缓存穿透问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="nav-number">2.2.13.1.</span> <span class="nav-text">问题描述：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.2.13.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.14.</span> <span class="nav-text">布隆过滤器原理及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.14.1.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">2.2.14.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.14.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.15.</span> <span class="nav-text">讲一下缓存雪崩问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.2.15.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="nav-number">2.2.15.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">2.2.16.</span> <span class="nav-text">讲一下缓存击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">2.2.16.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="nav-number">2.2.16.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">3.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82"><span class="nav-number">3.1.</span> <span class="nav-text">网络分层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-IP%E5%90%84%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.1.1.</span> <span class="nav-text">TCP&#x2F;IP各层结构与功能，以及常见协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">传输层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">网络层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="nav-number">3.1.1.4.</span> <span class="nav-text">网络接口层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-UDP"><span class="nav-number">3.2.</span> <span class="nav-text">TCP&#x2F;UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9FTCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%96%AD%E5%BC%80%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-number">3.2.1.</span> <span class="nav-text">TCP的三次握手和四次挥手的内容？TCP为什么连接是三次握手断开是四次挥手？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTCP%EF%BC%9F"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">什么是TCP？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">什么是TCP连接？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">三次握手的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">为什么要三次握手？不是两次、四次？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">四次挥手的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-number">3.2.1.6.</span> <span class="nav-text">为什么需要四次挥手？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">3.2.2.</span> <span class="nav-text">TCP与UDP的区别和使用场景？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">3.2.3.</span> <span class="nav-text">TCP如何保证可靠传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">3.2.4.</span> <span class="nav-text">TCP粘包问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">什么是粘包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B2%98%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">粘包的解决方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP"><span class="nav-number">3.3.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%EF%BC%9F"><span class="nav-number">3.3.1.</span> <span class="nav-text">HTTP报文格式？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">请求报文结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">响应报文结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">3.3.2.</span> <span class="nav-text">HTTP状态码有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">3.3.3.</span> <span class="nav-text">从输入URL到页面展示发生了什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URL%E5%92%8CURI%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.3.4.</span> <span class="nav-text">URL和URI有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">3.3.5.</span> <span class="nav-text">DNS有什么用？解析过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.3.6.</span> <span class="nav-text">HTTP和HTTPS的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">3.3.7.</span> <span class="nav-text">HTTPS的连接过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP1-0%E3%80%811-1%E3%80%812-0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.3.8.</span> <span class="nav-text">HTTP1.0、1.1、2.0的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1%E4%B8%8E1-0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">3.3.8.1.</span> <span class="nav-text">1.1与1.0的区别：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1%E5%92%8C2-0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">3.3.8.2.</span> <span class="nav-text">1.1和2.0的区别：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie%E5%92%8CSession%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">3.3.9.</span> <span class="nav-text">Cookie和Session了解吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie%E3%80%81Session%E3%80%81Token%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.3.10.</span> <span class="nav-text">Cookie、Session、Token的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Get%E5%92%8CPost%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.3.11.</span> <span class="nav-text">Get和Post的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E5%B1%82"><span class="nav-number">3.4.</span> <span class="nav-text">IP层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PING%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.4.1.</span> <span class="nav-text">PING有什么作用？工作原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">3.4.2.</span> <span class="nav-text">网络号和主机号有什么用？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.1.</span> <span class="nav-text">进程和线程的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">4.1.2.</span> <span class="nav-text">进程有哪几种状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">4.1.3.</span> <span class="nav-text">进程间的通信方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">4.2.1.</span> <span class="nav-text">常见的内存管理方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">4.2.2.</span> <span class="nav-text">分页管理的地址映射方式？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.3.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%92%8C%E7%9B%AE%E5%BD%95%E9%A1%B9"><span class="nav-number">4.3.1.</span> <span class="nav-text">文件系统中的索引节点和目录项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.2.</span> <span class="nav-text">软链接和硬链接的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.</span> <span class="nav-text">系统设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring"><span class="nav-number">5.1.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88Spring-IOC"><span class="nav-number">5.1.1.</span> <span class="nav-text">谈一谈Spring IOC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring-Bean%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AABean%EF%BC%9F"><span class="nav-number">5.1.2.</span> <span class="nav-text">什么是Spring Bean？如何声明一个Bean？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%8BSpring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="nav-number">5.1.3.</span> <span class="nav-text">简单描述下Spring Bean的生命周期？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Aware%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">Aware接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanPostProcessor"><span class="nav-number">5.1.3.2.</span> <span class="nav-text">BeanPostProcessor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InitializingBean-%E5%92%8C-init-method"><span class="nav-number">5.1.3.3.</span> <span class="nav-text">InitializingBean 和 init-method</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.1.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="nav-number">5.1.4.</span> <span class="nav-text">Spring如何解决循环依赖？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">三级缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">为什么是三级缓存？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">5.1.5.</span> <span class="nav-text">说一说对AOP的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-MVC%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">5.1.6.</span> <span class="nav-text">Spring MVC的核心组件有哪些？工作原理了解吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.1.7.</span> <span class="nav-text">Spring 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.1.7.1.</span> <span class="nav-text">声明式事务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Transactional%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.7.2.</span> <span class="nav-text">@Transactional失效场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.8.</span> <span class="nav-text">SpringBoot自动装配原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyBatis"><span class="nav-number">5.2.</span> <span class="nav-text">MyBatis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSQL%E6%B3%A8%E5%85%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="nav-number">5.2.1.</span> <span class="nav-text">什么是SQL注入，如何防止SQL注入？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81"><span class="nav-number">5.3.</span> <span class="nav-text">权限认证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie-%E5%92%8C-Session-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E2%BD%A4-Session-%E8%BF%9B%E2%BE%8F%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%EF%BC%9F"><span class="nav-number">5.3.1.</span> <span class="nav-text">Cookie 和 Session 有什么区别？如何使⽤ Session 进⾏身份验证？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Token%E5%92%8CSession%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.3.2.</span> <span class="nav-text">Token和Session有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="nav-number">5.4.1.</span> <span class="nav-text">单例模式了解么？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%AE%B2%E8%AE%B2spring%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">如何实现一个单例模式，讲讲spring中的单例模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="nav-number">5.4.1.2.</span> <span class="nav-text">单例模式线程安全吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">5.4.1.3.</span> <span class="nav-text">怎么保证一个单例的线程安全？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.4.2.</span> <span class="nav-text">观察者模式了解吗？说一下观察者模式的使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%BC%AF%E2%BC%9A%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E8%AF%B4%E2%BC%80%E4%B8%8B%E2%BC%AF%E2%BC%9A%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E2%BD%A4%E5%9C%BA%E6%99%AF%E3%80%82"><span class="nav-number">5.4.3.</span> <span class="nav-text">⼯⼚模式了解么？说⼀下⼯⼚模式的使⽤场景。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">5.4.4.</span> <span class="nav-text">装饰器模式？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">6.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-number">6.0.1.</span> <span class="nav-text">为什么要用消息队列？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD"><span class="nav-number">6.0.1.1.</span> <span class="nav-text">异步处理提高系统性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8A%E5%B3%B0-%E9%99%90%E6%B5%81"><span class="nav-number">6.0.1.2.</span> <span class="nav-text">削峰&#x2F;限流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88%E6%80%A7"><span class="nav-number">6.0.1.3.</span> <span class="nav-text">降低系统耦合性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rocket-MQ%E6%A6%82%E8%BF%B0"><span class="nav-number">6.0.2.</span> <span class="nav-text">Rocket MQ概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rocket-MQ%E7%9A%84%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">6.0.3.</span> <span class="nav-text">Rocket MQ的消息消费失败怎么办？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rocket-MQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="nav-number">6.0.4.</span> <span class="nav-text">Rocket MQ如何保证消息不丢失？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="nav-number">6.0.4.1.</span> <span class="nav-text">发送消息怎么保证不丢失？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Broker%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="nav-number">6.0.4.2.</span> <span class="nav-text">Broker处理消息怎么保证不丢失？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Consumer%E6%B6%88%E8%B4%B9%E9%98%B6%E6%AE%B5%EF%BC%9F"><span class="nav-number">6.0.4.3.</span> <span class="nav-text">Consumer消费阶段？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="nav-number">6.0.5.</span> <span class="nav-text">如何保证消息不被重复消费？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="nav-number">6.0.6.</span> <span class="nav-text">如何保证顺序消费？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%9C%89%E5%BA%8F%E5%8F%91%E9%80%81"><span class="nav-number">6.0.6.1.</span> <span class="nav-text">生产者有序发送</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%9C%89%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="nav-number">6.0.6.2.</span> <span class="nav-text">消费者有序消费</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka%E4%B8%8ERocket-MQ%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">6.0.7.</span> <span class="nav-text">Kafka与Rocket MQ区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Cloud-Stream%EF%BC%9F"><span class="nav-number">6.0.8.</span> <span class="nav-text">Spring Cloud Stream？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">场景题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">7.1.</span> <span class="nav-text">高并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%B9%B6%E5%8F%91%E9%87%8F%EF%BC%9F"><span class="nav-number">7.1.1.</span> <span class="nav-text">秒杀场景怎么设计？如何提高并发量？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E6%8E%A5%E5%8F%A3%E5%B9%B6%E5%8F%91%E9%87%8F%E9%AB%98%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">7.1.2.</span> <span class="nav-text">读接口并发量高怎么优化？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E6%B5%81"><span class="nav-number">7.1.2.1.</span> <span class="nav-text">限流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">7.1.2.2.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">7.1.2.3.</span> <span class="nav-text">数据库查询优化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">8.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E7%B3%BB%E7%BB%9F"><span class="nav-number">8.1.</span> <span class="nav-text">Linux系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linux%E5%B8%B8%E8%80%83%E5%91%BD%E4%BB%A4"><span class="nav-number">8.1.1.</span> <span class="nav-text">linux常考命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Cat%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">Cat命令：查看文件内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#find%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">find命令：搜索文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#grep%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="nav-number">8.1.1.3.</span> <span class="nav-text">grep命令：文本处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jps%E5%91%BD%E4%BB%A4"><span class="nav-number">8.1.1.4.</span> <span class="nav-text">jps命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ps%E5%91%BD%E4%BB%A4"><span class="nav-number">8.1.1.5.</span> <span class="nav-text">ps命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kill%E5%91%BD%E4%BB%A4"><span class="nav-number">8.1.1.6.</span> <span class="nav-text">kill命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#top%E5%91%BD%E4%BB%A4"><span class="nav-number">8.1.1.7.</span> <span class="nav-text">top命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#netstat%E5%91%BD%E4%BB%A4"><span class="nav-number">8.1.1.8.</span> <span class="nav-text">netstat命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tar%E5%91%BD%E4%BB%A4"><span class="nav-number">8.1.1.9.</span> <span class="nav-text">tar命令</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
